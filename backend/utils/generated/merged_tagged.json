[
    {
        "key": "merged_topic_0_0",
        "label": "constant, symbolic, define, defines, evaluable, constants, numeric, sequence",
        "input": "<task:merge> <sos>\nThe definition section defines all symbolic constant\nConstant Tokens Keywords Constant Strings Operators Identifiers Special Symbol Constant is referring to fixed values that do not change during the execution of a program\nCONSTANT Numeric constant Character Constant Variable A variable is a data name that may be used to store a data value\nDefining Symbolic constant Syntax define symbolicname value of constant Eg define pi define max The following rules apply todefine statement which defines a symbolic constant\nvaluevalue are constants or constant expressions ( evaluable to an integer constant ) and are known as case labels\n( ) Fortran Constant A number on a string of FORTRAN characters is called a constant\n\n++++\n\nThe definition defines all the symbolic constants\nThey are often referred to collectively as numeric _ type constants\nSymbolic Constants A symbolic constant is a name that substitutes for a sequence of characters\nThus a symbolic constant allows a name to appear in place of a numeric constant a character constant or a string\nWhen a program is compiled each occurrence of a symbolic constant is replaced by its corresponding character sequence\nSymbolic constants are usually defined at the beginning of a program\nThe symbolic constants may then appear later in the program in place of the numeric constants character constant etc that the symbolic constants represent\nA symbolic constant is defined by writing define name text where name represents a symbolic name typically written in uppercase letters and text represents the sequence of characters that is associated with the symbolic name\nWhat is Symbolic constant differentiate between keywords and identifier\n<eos>"
    },
    {
        "key": "merged_topic_1_0",
        "label": "pointer, operator, subtract, integers, operators, shift, regarded, exponential",
        "input": "<task:merge> <sos>\nC operators can be classified into a number of categories\nSpecial operators C support some special operators of interest such as comma operator sizeof operator pointer operator ( and ) and member selection operator (\nExample X ( int ) ie is converted to integer by truncation Operator precedence and associativity Precedence is used to determine how an expression involving more than one operator is evaluated\nExample int a int pa Pointer Expression C allows us to add integers to or subtract integers from pointers as well as to subtract one pointer from another\nPppp In addition to arithmetic operations discussed pointer can also be compared using the relational operators\nWe may no use pointer in division or multiplication\nPointer increment and scalar factor When we increment a pointer its value is increased by the length of the data type that it points to\n\n++++\n\nC includes a number of operators which fall into several different categories such as arithmetic operators unary operators rational and logical operators assignment operators and the conditional operators bitwise operator\nOperators Arithmetic Operators There are five arithmetic operators in C They are Operators Purposes Addition Subtraction Multiplication Division remainder after integer division ( also called modulus operator ) There is no exponential operator in C However there is a library function ( pow ) to carry out exponential\nThe relational operators in C are listed as Operators Meaning greater than greater than or equal to Equality equal to\nfalse In addition to the relational and equality operators C also includes the unary operator\nLogical operators C contains three logical operators Operator Meaning and or\nOperator is referred as logic and the operator is referred as logic or\nC contains the following five additional assignment operators and\na f a shift shift shift g Special Operators C supports some special operators such as comma operator size of operator pointer operator ( and ) and member selection operators\nWrite the general form of ternary operator and explain with example\nWhat are the various types of operators used in C language\nDescribe unary binary and ternary operators with examples\n<eos>"
    },
    {
        "key": "merged_topic_2_0",
        "label": "label, jump, goto, forward, backward, statement, illegible, colon",
        "input": "<task:merge> <sos>\nIn both the cases the control is transferred subsequently to the statementx\nThe goto requires a label in order to identify the place where the branch is to be made\nThe label is placed immediately before the statement where the control is to be transferred\nThe general forms of goto and label statements are shown below goto label label statement label statement goto label Forward jump Backward jump Note that a goto breaks the normal sequential execution of the program\nIf the label is before the statement goto label a loop will be formed and some statements will be executed repeatedly\nSuch jump is known as a backward jump\nOn the other hand if the label is placed after the goto label some statements will be skipped and the jump is known as a forward jump\nAnother use of the goto statement is to transfer the control out of the loop ( or nested loop ) when certain peculiar conditions are encountered\nAvoiding goto When a goto is used many compilers generate a less efficient code\nJump Statement The jump statement unconditionally transfers program control one point to another point in a program\n\n++++\n\nThe goto statement transfers the control to the labeled statement somewhere in the current function\nThe general syntax of goto statement goto label label statement Here label is any valid C identifier and it is followed by a colon\nWhenever the statement goto label is encountered the control is transferred to the statement that is immediately after the label\nGenerally the use of goto statement is avoided as it makes program illegible and unreliable\n<eos>"
    },
    {
        "key": "merged_topic_3_0",
        "label": "satisfied, loop, body, looping, condition, executed, statements",
        "input": "<task:merge> <sos>\nDecision making and looping Looping ( or iteration ) is the process of executing a sequence of statements until some condition for termination of loop is satisfied\nIf the conditions are not satisfied then the body of the loop will not be executed\nIf the condition is true the program continues to evaluate the body of the loop once again\nIf the condition is true the body of loop is executed otherwise the loop is terminated and execution continues with the statement that immediately follows the loop\nIf the condition is satisfied the body of the loop is again executed\n\n++++\n\nThis ensures that the algorithm will ultimately terminate\nSo a loop may be defined as a block of statements which are repeatedly executed for a certain number of times or until a particular condition is satisfied\nThe control statement in loop decides whether the body is to be executed or not\nAfter the execution again the condition is checked and if it is found to be true then again the statements in the body of loop are executed\nThe body of this loop may contain a single statement or a block of statements\nIf the condition is true then again the loop body is executed and this process continues until the condition becomes false\nInstead the remaining loop statements are skipped and the computation proceeds directly to the next pass through the loop\n<eos>"
    },
    {
        "key": "merged_topic_4_0",
        "label": "getchar, character, formatted, putchar, input, getche, putch",
        "input": "<task:merge> <sos>\nManaging input and output operation Reading a character Reading a single character can be done by using the function getchar\nThe getchar takes the following form variable_namegetchar ( ) Variable_name is a valid C name that has been declared as char type\nWhen this statement is encountered the computer waits until a key is pressed and then assigns this character as a value to getchar function\nSince getchar is used on the right hand side of an assignment statement the character value of getchar is in turn assigned to the variable name on the left\nFor example char name namegetchar ( ) The getchar ( ) function accept any character keyed in\nThis could create problem when we use getchar ( ) in a loop interactively\nWriting a character Like a getchar there is a analogous function putchar for writing characters one at a time to the terminal\nIt takes the form as shown below putchar ( variable_name ) where variable_name is a type char variable containing a character\n\n++++\n\ngetchar ( ) and putchar ( ) The getchar ( ) function reads a character from a standard input device\nThe general syntax is character_variable getchar ( ) where character_variable is a valid C char type variable\nWhen this statement is encounted the computer waits until a key is pressed and assign this character to character_variable\nThe putchar ( ) function displays a character to the standard output device\nThe general syntax of putchar ( ) function is putchar ( character_variable ) where character_variable is a char type variable containing a character\ngetch ( ) getche ( ) and putch ( ) The functions getch ( ) and getche ( ) reads a single character the instant it is typed without waiting for the enter key to be hit\nThe difference between them is that getch ( ) reads the character typed without echoing it on the screen while getche ( ) reads the character and echoes ( displays ) it on the screen\n<eos>"
    },
    {
        "key": "merged_topic_4_1",
        "label": "getchar, character, formatted, putchar, input, getche, putch",
        "input": "<task:merge> <sos>\nFor example answerY putchar ( answer ) this statement display the character Y include include void main ( ) char name char ch int i printf ( nEnter the name ) while ( ( chgetchar ( ) ) n ) nameich i namei printf ( nThe name is s name ) getch ( ) Formatted input Formatted input refers to an input data that has been arranged in particular format\nFor example scanf ( f f f x y z ) Inputting Character Strings Scanf can input strings containing more than one character\nFollowing are the specifications for reading character strings ws or wc Formatted output The printf statement provides certain features that can be effectively exploited to control the alignment and spacing of printout on the terminals\nCharacters that will be printed on the screen as they appear\nReading line of text scanf with s or ws can read only string without whitespaces\nthat can be used to read a line containing a variety of characters including whitespace\n\n++++\n\nThe general syntax of getch ( ) character_variable getch ( ) Similarly the syntax of getch ( ) is character_variable getche ( ) The putch ( ) function prints a character onto the screen\nThe general syntax is putch ( character_variable ) These three functions are defined under the standard library function conioh and hence we should include this in our program using the instruction include include main ( ) char ch ch clrscr ( ) printf ( Enter first character ) ch getch ( ) printf ( n Enter second character ) ch getche ( ) printf ( n First character ) putch ( ch ) printf ( n Second character ) putch ( ch ) Output Enter first character Enter second character b First character a Second character b Since the first input is taken using getch ( ) function the character a entered is not echoed\nHowever using getche ( ) function we can see what we have typed\nThe last getch ( ) simply takes a character but doesnot store it anywhere\n<eos>"
    },
    {
        "key": "merged_topic_4_2",
        "label": "getchar, character, formatted, putchar, input, getche, putch",
        "input": "<task:merge> <sos>\nFor example char name scanf ( nname ) printf ( sname ) Note we can use getchar and gets functions to take input to character array variable\nFor example to getchar look at unformatted input example\n\n++++\n\ngets ( ) and puts ( ) The gets ( ) function is used to read a string of text containing whitespaces until a newline character is encountered\nThe general syntax of gets ( ) is gets ( string_variable ) The puts ( ) function is used to display the string onto the terminal\nThe general syntax of puts ( ) is puts ( string _variable ) This prints the string value of string_variable and then moves the cursor to the beginning of the next line on the screen\n( PU ) Distinguish between getc ( ) a getchar ( )\n<eos>"
    },
    {
        "key": "merged_topic_5_0",
        "label": "marks, student, total, float, highest, grade, roll, remarks",
        "input": "<task:merge> <sos>\nof a student and marks obtained by him in subjectsDeclare array to hold the data of students\nPass this to a function that displays the marks of student who has a highest total marks\n\n++++\n\nM Singh ) printf ( n Names name ) name ( char ) realloc ( ame ) strcpy ( namecaptain B M Singh ) pritf ( nNamesname ) getch ( ) output Name B M Singh Name Captain B M Singh Program to read marks obtained by ditstudent calculate sum average using pointer include include include main ( ) int n i float p sum avg clrscr ( ) printf ( n How Many Students aretheret ) scanf ( dn ) printf ( n Enter marks of each studentsn ) p ( float ) malloc ( nsizeof ( float ) ) for ( i in i ) scanf ( f ( pi ) ) avgsumn printf ( The average marks of ) for ( i in i ) printf ( f t ( p i ) ) printf ( f t is avg ) free ( P ) getch ( ) output How many students are there\nEnter marks of each student The average marks of is write a pg to read an array of n integers using dynamic memory allocation and display the largest and smallest element int main ( ) int n i intnummaxmin clrscr ( ) printf ( n enter number of elements in our array ) scanf ( dn ) num ( int ) calloc ( nsizeof ( int ) ) printf ( nEnterd integersn ) for ( i i ( numi ) ) min ( numi ) printf ( n the maximum numberdmax ) printf ( n the minimum numberdmin ) getch ( ) output Enter numbers of element in our array Enter integers The maximum number The minimum number Some Important Questions What are the relationship between arrays and pointer\n<eos>"
    },
    {
        "key": "merged_topic_5_1",
        "label": "marks, student, total, float, highest, grade, roll, remarks",
        "input": "<task:merge> <sos>\ninclude include struct student int roll int marks int total void input ( struct student s ) int ij for ( iii ) printf ( nEnter the roll number of student ) scanf ( dsiroll ) printf ( nEnter marks for subjects ) sitotal for ( jjj ) scanf ( dsimarksj ) sitotalsitotalsimarksj void display ( struct student s ) int ilocationmax maxstotal location for ( iii ) if ( maxsitotal ) serching highest marks location maxsitotal locationi printf ( nRecord of student who score highest marks ) printf ( nRoll number of studentdslocationroll ) printf ( nEnter marks for subjects ) for ( iii ) printf ( nMarks in d subjectdislocationmarksi ) void main ( ) struct student civil input ( civil ) display ( civil ) getch ( ) Create a structure STUDENT containing name symbol number name of subjects mark of each subject and total mar as its members\nWrite a program that uses this structure and reads data for a student and gives the total marks as the output\n\n++++\n\nWAP using structure to read and display the data entered by the user include main ( ) struct student char name int roll float marks char remark struct student s clrsc ( ) printf ( enter name t ) gets ( sname ) printf ( In enter rollt ) scanf ( d sroll ) printf ( n enter marks t ) scanf ( f smarks ) printf ( enter remarks p for pass or f for fail t ) sremark getch ( ) printf ( nn The students information is n ) printf ( Student Name ItItIt Roll It Marks It Remarks ) printf ( n n ) printf ( sttdtftc sname sroll smarks sremark ) getch ( ) output enter name Ram Singh enter roll Enter remark p for pass or f for fail P The students information is Student Name Roll Marks Remarks Ram Singh P Array of Structure Like array of int float or char type there may be array of structure\n<eos>"
    },
    {
        "key": "merged_topic_6_0",
        "label": "constant, real, point, fractional, mantissa, base, constants, integer, rarely, decimal",
        "input": "<task:merge> <sos>\nNumber are called numeric constant\netc are some numeric constants\nThere are two types of Numeric Constant\nReal Constant INTEGER Constant Integer written without decimal point is called fixed point constant or integer constants\nNo other character should occur in fixed point constant\nReal Constant Any number written with one decimal point is called a floating point constant of real constant\nA real constant can be expressed in any one of the following two forms i ) Fractional form ii ) Exponential form The following rules apply for the real constant in fractional form\nA real constant is written in the decimal form with the digitals and the decimal point\nNo special symbols such as etc are allowed in a real constant\nThe general form of the exponential floating point constant is Mantissa E exponent\nThe mantissa must be valid real constant in fractional form\nAll the rules of the fractional form applied to the mantissa\n\n++++\n\nInteger and floating point constants represent numbers\nInteger Constants An integer constant is an integervalued number\nInteger ( number ) constants can be written in three different number systems decimal ( base ) octal ( base ) and hexadecimal ( base )\nBeginning programmers rarely however use anything other than decimal integer constants\n<eos>"
    },
    {
        "key": "merged_topic_7_0",
        "label": "testcondition, body, continues, loop, process, executed, condition, statements",
        "input": "<task:merge> <sos>\nBody of the loop\nThe testcondition is evaluated and if the condition is true then the body of the loop is executed\nAfter execution of the body the test condition is once again evaluated and if it is true the body is executed once again\nThis process of repeated execution of the body continues until the testcondition finally becomes false and the control is transferred out of the loop\nBody of the loop Test condition\nThis process continues as long as the condition is true\nSince the testcondition is evaluated at the bottom of the loop the dowhile construct provides an exitcontrolled loop and therefore the body of the loop is always executed at least once\nThe value of the control variable is tested using the testcondition\nThis process continues till the value of the control variable fails to satisfy the testcondition\n\n++++\n\nThis ensures that the algorithm will ultimately terminate\nSo a loop may be defined as a block of statements which are repeatedly executed for a certain number of times or until a particular condition is satisfied\nThe control statement in loop decides whether the body is to be executed or not\nAfter the execution again the condition is checked and if it is found to be true then again the statements in the body of loop are executed\nThe body of this loop may contain a single statement or a block of statements\nIf the condition is true then again the loop body is executed and this process continues until the condition becomes false\nInstead the remaining loop statements are skipped and the computation proceeds directly to the next pass through the loop\n<eos>"
    },
    {
        "key": "merged_topic_8_0",
        "label": "constant, real, point, fractional, mantissa, unsigned, long, floating, appending, constants",
        "input": "<task:merge> <sos>\nNumber are called numeric constant\netc are some numeric constants\nThere are two types of Numeric Constant\nReal Constant INTEGER Constant Integer written without decimal point is called fixed point constant or integer constants\nNo other character should occur in fixed point constant\nReal Constant Any number written with one decimal point is called a floating point constant of real constant\nA real constant can be expressed in any one of the following two forms i ) Fractional form ii ) Exponential form The following rules apply for the real constant in fractional form\nA real constant is written in the decimal form with the digitals and the decimal point\nNo special symbols such as etc are allowed in a real constant\nThe general form of the exponential floating point constant is Mantissa E exponent\nThe mantissa must be valid real constant in fractional form\nAll the rules of the fractional form applied to the mantissa\n\n++++\n\nAn unsigned integer constant can be identified by appending the letter ( ) ( either upper or lowercase ) to the end of the constant\nLong integer constants may exceed the magnitude of ordinary integer constants but require more memory within the computer\nA long integer constant can be identified by appending the letter L ( either upper or lowercase ) to the end of the constant\nAn unsigned long integer may be specified by appending the letters UL to the end of the constant\nHowever the U must preced the L Several unsigned and long integer constants are shown below Constant Number System U decimal ( unsigned ) L decimal ( long ) UL decimal ( unsigned long ) L octal ( long ) U octal ( unsigned ) XFFFFFUL hexadecimal ( unsigned long ) Floating Point Constants A floating point constant is a base number that contains either a decimal point or an exponent ( or both )\nSeveral valid floating point constants\nE e e The following are not valid floating point constants for the reason stated\n<eos>"
    },
    {
        "key": "merged_topic_9_0",
        "label": "content, mode, file, existing, opens, exist, new, erased",
        "input": "<task:merge> <sos>\nFile opening Modes The different types of file opening modes are r This mode open file for reading only\nw This mode open file for writing only\na This mode open file for appending ( or adding ) data to it\nWhen the file is opened in this mode the file is opened with the current content safe\nr This mode opens the file for reading existing content writing new contents and modifying existing content of the file\nw This mode opens the file for writing new content reading them back and modifying the existing content of the file\na This mode opens the file for appending new content to the end of file reading existing content from the file But can not modify existing contents\n\n++++\n\nread write append etc )\nw ( write ) If the file dosent exist then this mode creates a new file for writing and if the file already exists then the previous data is erased and the new data entered is written to the file\na ( append ) If the file doesnt exist then this mode creates a new file and if the file already exists then the new data entered is appended at the new data entered is appended at the end of existing data\nIn this mode the data existing in the file is not erased as in w mode\nr ( read ) This mode is used for opening an existing file for reading purpose only\nThe file to be opened must exist and the previous data of file is not erased\nw ( write read ) This mode is same as w mode but in this mode we can also read and modify the data\nIf the file doesnt exist then a new file is created and if the file exists then previous data is erased\nr ( read write ) This mode is same as r mode but in this mode we can also write and modify existing data\nSince we can add new data and modify existing data so this mode is also called update mode\n<eos>"
    },
    {
        "key": "merged_topic_9_1",
        "label": "content, mode, file, existing, opens, exist, new, erased",
        "input": "<task:merge> <sos>\nAttempting to write a writeprotected file\n\n++++\n\nat ( append read ) This mode is same as the a mode but in this mode we can also read the data stored in the file\nIf the file doesnt exist a new file is created and if the file already exists then new data is appended at the end of existing data in this mode\n<eos>"
    },
    {
        "key": "merged_topic_10_0",
        "label": "section, closing, brace, executable, appear, userdefined, prototypes, ahead, function",
        "input": "<task:merge> <sos>\nThis means that we can execute them directly but can not read or modify them\nThis section also declares all the userdefined functions\nEvery C program must have one main ( ) function section\nThis section contains two parts declaration part and executable part\nThe declaration part declares all the variables used in the executable part\nThere is at least one statement in the executable part\nThese two parts must appear between the opening and the closing braces\nThe program executing begins at the opening brace and ends at the closing brace\nThe closing brace of the main function section is the logical end of the program\nAll statements in the declaration and executable parts end with a semicolon ( )\nThe subprogram section contains all the userdefined functions that are called in the main function\nUserdefined functions are generally placed immediately after the main function although they may appear in any order\nAll section except the main function section may be absent when they are not required\ndefine statements must not end with a semicolon\ndefine statements may appear anywhere in the program but before it is referenced in the program\nThere is no need to put braces around these blocks\nThe unit can be invoked from other part of the program\n\n++++\n\nOne of the function must be called main ( ) A function is a subroutine that may include one or more statements designed to perform a specific task\nEvery C program must have one main ( ) function section\nThe subprogram section contains all the userdefined functions that are called in the main ( ) function\nUserdefined functions are generally placed immediately after the main ( ) function although they may appear in any order\nAll section except the main ( ) function section may be absent when they are not required\nThe function main ( ) is always present in each program which is executed first and other functions are optional\nThe function main ( ) is an user defined function except that the name of function is defined or fixed by the language\n<eos>"
    },
    {
        "key": "merged_topic_10_1",
        "label": "section, closing, brace, executable, appear, userdefined, prototypes, ahead, function",
        "input": "<task:merge> <sos>\nSuch declaration is available for all the function in the program\nFunction Definition A function must be defined before it is used anywhere in the program\nadd ( ) When the compiler encounters the function call the control is transferred to the function definition\nAnd it executes each line of code in function and returns the control to the main program again\nA function may be used by many other program\nThis is a nonexecutable statement\n\n++++\n\nThis function is executed first when the program starts execution\nFunction Declaration or Prototype The function declaration or prototype is model or blueprint of the function\nIf functions are used before they are defined then function declaration or prototype is necessary\nMany programmers prefer a topdown approach in which main appears ahead of the programmer defined function definition\nFunction prototypes are usually written at the beginning of a program ahead of any userdefined function including main ( )\nFunction prototypes provide the following information to the compiler\nIn bottomup approach where userdefined functions are defined ahead of main ( ) function there is no need of function prototypes\n<eos>"
    },
    {
        "key": "merged_topic_11_0",
        "label": "function, calling, return, does, receive, keyword, argument",
        "input": "<task:merge> <sos>\nVoid data type ( for empty set of value and nonreturning functions ) the void type specifies an empty set of values\nIt is used as the return type for functions that do not return a value\nFunction with no arguments and no return values When a function has no argument it does not receive any data from the calling function\nSimilarly when it does not return value the calling function does not receive any data from the called function\nFunction with no argument and return type In this function the function does not take any input from the calling function but it returns value to the calling function\nRecursive A function is said to be recursive if a statement in the body of the function calls itself\nThe return statement is necessary only when the function is returning some data back to the calling function\n\n++++\n\nIf there is no return value the keyword void is used\nThere are two ways in which it can be used return return ( expression ) where return is a keyword\nIn this case only return keyword is written\nThe value returned by the return statement may be any constant variable expression or even any other function call which returns a value\nSimilarly when called function does not return a value the calling function does not receive any data from it\nThere is no argument within parenthesis which implies function has no argument and it doesnt receive any data from the called function\n<eos>"
    },
    {
        "key": "merged_topic_12_0",
        "label": "position, current, offset, fseek, file, putw, syntax, rewind",
        "input": "<task:merge> <sos>\nftell takes a file pointer and return a number of type long that corresponds to the current position\nThis function is useful in saving the current position of a file which can be used later in the program\nIt takes the following form N fte ( fp ) n would give the relative offset ( in bytes ) if the current position\nThis function helps us in reading a file more than once without having to close and open the file\nfseek function is used to move the file position to a desired location within the file\n\n++++\n\nIts syntax is char_variable fget ( file_ptr_variable ) fputc ( ) It is used to write a character to a file\nIts syntax is fputc ( char_variable file_ptr vriable ) b ) String IO functions fgets ( ) It is used to read string from file\nIts syntax is fgets ( string int_value file_ptr_variable ) fputs ( ) It is used to write a string to a file\nIts syntax is fputs ( string file_ptr_variable )\nIts syntax is fprintf ( file_ptr_variablecontrol string list variables ) fscanf ( ) This function is used to read some integer float char or string froma file\nIts syntax is fscanf ( file_ptr_variablecontrol string list_variables ) Creating data files Some sample programs create a file named testtxt and write some text Welcome to Eastern College of Engineering to the file\nFile Pointer Device Stdin Standard input device ( keyboard ) Stdout Standard OUTPUT devices ( screen ) Stderr Standard error OUTPUT device ( screen ) Some other unformatted function Intger IO getw ( ) putw ( ) for binary mode Record IO fread ( ) fwrite Putw ( ) used to write integer value th file\nTheir syntaxes are int putw ( int value FILE fpir ) int getw ( FILE fptr ) fwrite ( ) used for writing an etire block to a given file\n<eos>"
    },
    {
        "key": "merged_topic_12_1",
        "label": "position, current, offset, fseek, file, putw, syntax, rewind",
        "input": "<task:merge> <sos>\nIt takes the following form fseek ( file_ptroffsetposition ) file_ptr is a pointer to the file concerned offset is a number or variable of type long and position is an integer number\nthe offset specifies the number of position ( byte ) to be moved from the location specified by position\nThe position can take one of the following three values value meaning Beginning of file Current position End of file Example fseek ( fpL ) meaning go to begining refer to class note for example FORTAN character set The following is the set of character used in FORTRAN\n\n++++\n\nTheir syntax are fwrite ( ptr size_of_array_or_structure number_of_array_or_structure fptr ) fread ( ptr size_of _array_or_structure number_of_structure_or_array fptr ) Random Acess to File We can acess the data stored in the file in two ways sequently or random\nThe syntax is int fseek ( FILE fp long displacement int origin ) where fp is file pointer displacement is long integer which can be positive or negative and it denotes the number of bytes which are skipped backward ( if negative ) or forward ( if positive ) from the position specified in the third argument\nIt can take one of these three values Constant Value Poition SEEK_SET Beginning of file SEEK_CURRENT Current position SEEK_END End of File rewind ( ) This function is used to move the file position positive to the beginning of the file syntax rewind ( File fp ) using rewind ( fp ) is equivalent to fseek ( fp OL O ) ftell ( ) This function returns the current position of the file position pointer\n<eos>"
    },
    {
        "key": "merged_topic_13_0",
        "label": "programmer, operating, crashing, conjunction, thorough, algebraic, augmented, assisting, visual, road",
        "input": "<task:merge> <sos>\nIt is a set of instructions that tells the computer what to do when the computer operator does something\nIt operates in close conjunction with operating system and enables us ( the programmer ) to exploit certain capabilities of operating system while creating the program\nIt requires a thorough knowledge ( low level ) of the hardware for which the program is being created\nIf not it will inform the programmer where rules have been violated\nIt should be able to detect unreasonable or error conditions and indicate them to the programmer or user without stopping all operations crashing the system\nIt facilitates topdown modular programming\nIt is easy to locate and isolate a faulty function for further investigations\n\n++++\n\nIt is simply a method of assisting the program to lay out in a visual two dimensional format ideas on how to organize a sequence of steps necessary to solve a problem by a computer\nIt is basically the plan to be followed when a program is written\nIt acts like a road map for a programmer and guides himher how to go from starting point to the final point while writing a computer program\nIt displays the dynamics of a program and allows us to examine and compare the information at various points\nIts instructions consists of terms that resemble algebraic expression augmented by certain English keywords such as if else for do and while etc\n<eos>"
    },
    {
        "key": "merged_topic_14_0",
        "label": "file, opening, data, defined, secondary, files, level, high, buffer, oriented",
        "input": "<task:merge> <sos>\nThe basic file operations performed are Naming a file Opening a file Reading data from a file Writing data from a file Closing a file\nDefining and opening a file If we want to perform operation in a file in the secondary memory we must specify certain things about the file to the operating system\nExample Studenttxt Employdat Data structure of a file is defined as FILE in the library of standard IO function definitions\nTherefore all files should be declared as type FILE before they are used\nFILE is a defined data type\nFor example we may write data to the file or read the already existing data\nFollowing is the general format for declaring and opening a file FILE fp fp fopen ( filenamemode ) the first statement declares the variable fp as a pointer to the data type FILE\nThe second statement opens the file named filename and assigns an identifier to the FILE type pointer fp\n\n++++\n\nProgramming language C has various library functions for creating and processing data files\nHigh level ( standard or stream oriented ) files\nLow level ( system oriented ) files\nIn high level data files the available library functions do their own buffer management where as the programmer should do it explicitely in case of lower level files\nFor each binary and text files there are a number of formatted and unformatted library functions in C fig classification of files Data files High Low Text Binary Opening and closing a data file Before a program can write to a file or read from a file the program must open it\nWhile working with high level data file we need buffer area where information is stored temporarily in the course of transferring data between computer memory and data file\nA structure named FILE is defined in the file stdioh that contains all information about the file like name status buffer size current position and of file status etc\n( PU ) What is a files ad explain its importance in C programming\nWhat is a file\n<eos>"
    },
    {
        "key": "merged_topic_15_0",
        "label": "prototype, declaration, local, function, global, parameter, type, returned, mul, return",
        "input": "<task:merge> <sos>\nFunction declaration or Function prototype\nFunction Prototype A function prototype is a declaration of the function that tells the program about the type of the value returned by the function and the number and type of each argument\nFunctiontype functionname ( parameter list ) Example void sum ( int a int b ) when we place the declaration above all the function ( in the global declaration section ) the prototype is referred to as global prototype\nWhen we place it in a function definition ( in the local declaration section ) the prototype is called a local prototype\nThe prototype declaration should be similar to the function header\n\n++++\n\nThe general syntax of function prototype is return_type function_name ( type type typen ) where return_type specifies the data type of the value returned by the function\nA function can return value of any data type\nThe general syntax is return_type function_name ( parameter parameter parametern ) statements where return_type is the data type specifier of data returned by the function\nThe syntax of teh call if function return_type is void is function_name ( parameter name ) If function return int float or any other type value then we have to assign the call to same type value like variable function_name ( parameter ) For example m mul ( x y ) The type of m is same as the return type of mul function\nThis type of function is defined as void function_name ( ) body of function The keyword void means the function does not return any value\n<eos>"
    },
    {
        "key": "merged_topic_16_0",
        "label": "file, opening, data, defined, secondary, position, putw, syntax, rewind",
        "input": "<task:merge> <sos>\nThe basic file operations performed are Naming a file Opening a file Reading data from a file Writing data from a file Closing a file\nDefining and opening a file If we want to perform operation in a file in the secondary memory we must specify certain things about the file to the operating system\nExample Studenttxt Employdat Data structure of a file is defined as FILE in the library of standard IO function definitions\nTherefore all files should be declared as type FILE before they are used\nFILE is a defined data type\nFor example we may write data to the file or read the already existing data\n\n++++\n\nIts syntax is char_variable fget ( file_ptr_variable ) fputc ( ) It is used to write a character to a file\nIts syntax is fputc ( char_variable file_ptr vriable ) b ) String IO functions fgets ( ) It is used to read string from file\nIts syntax is fgets ( string int_value file_ptr_variable ) fputs ( ) It is used to write a string to a file\nIts syntax is fputs ( string file_ptr_variable )\nIts syntax is fprintf ( file_ptr_variablecontrol string list variables ) fscanf ( ) This function is used to read some integer float char or string froma file\nIts syntax is fscanf ( file_ptr_variablecontrol string list_variables ) Creating data files Some sample programs create a file named testtxt and write some text Welcome to Eastern College of Engineering to the file\nFile Pointer Device Stdin Standard input device ( keyboard ) Stdout Standard OUTPUT devices ( screen ) Stderr Standard error OUTPUT device ( screen ) Some other unformatted function Intger IO getw ( ) putw ( ) for binary mode Record IO fread ( ) fwrite Putw ( ) used to write integer value th file\nTheir syntaxes are int putw ( int value FILE fpir ) int getw ( FILE fptr ) fwrite ( ) used for writing an etire block to a given file\n<eos>"
    },
    {
        "key": "merged_topic_16_1",
        "label": "file, opening, data, defined, secondary, position, putw, syntax, rewind",
        "input": "<task:merge> <sos>\nFollowing is the general format for declaring and opening a file FILE fp fp fopen ( filenamemode ) the first statement declares the variable fp as a pointer to the data type FILE\nThe second statement opens the file named filename and assigns an identifier to the FILE type pointer fp\n\n++++\n\nTheir syntax are fwrite ( ptr size_of_array_or_structure number_of_array_or_structure fptr ) fread ( ptr size_of _array_or_structure number_of_structure_or_array fptr ) Random Acess to File We can acess the data stored in the file in two ways sequently or random\nThe syntax is int fseek ( FILE fp long displacement int origin ) where fp is file pointer displacement is long integer which can be positive or negative and it denotes the number of bytes which are skipped backward ( if negative ) or forward ( if positive ) from the position specified in the third argument\nIt can take one of these three values Constant Value Poition SEEK_SET Beginning of file SEEK_CURRENT Current position SEEK_END End of File rewind ( ) This function is used to move the file position positive to the beginning of the file syntax rewind ( File fp ) using rewind ( fp ) is equivalent to fseek ( fp OL O ) ftell ( ) This function returns the current position of the file position pointer\n<eos>"
    },
    {
        "key": "merged_topic_18_0",
        "label": "pointer, operator, subtract, integers, operators, precedence, associativity, left, right",
        "input": "<task:merge> <sos>\nC operators can be classified into a number of categories\nSpecial operators C support some special operators of interest such as comma operator sizeof operator pointer operator ( and ) and member selection operator (\nExample X ( int ) ie is converted to integer by truncation Operator precedence and associativity Precedence is used to determine how an expression involving more than one operator is evaluated\nExample int a int pa Pointer Expression C allows us to add integers to or subtract integers from pointers as well as to subtract one pointer from another\nPppp In addition to arithmetic operations discussed pointer can also be compared using the relational operators\nWe may no use pointer in division or multiplication\nPointer increment and scalar factor When we increment a pointer its value is increased by the length of the data type that it points to\n\n++++\n\nPrecedence Associativity Precedence of an operator in C is defined as the order of evaluation\nThe operators are grouped hierarchically according to their precedence\nOperations with a high precedence are carried out before operation having a lower precedence\nWithin each of the precedence groups described above the associativity is left to right\nOperators not equal to These operators all fall within the same precedence group which is lower than the arithmetic and unary operators\nThe associativity of these operators is left to right\nThe associativity of size of right to left\nGive a table that shows their precedence and associatively\nThe dot operator has precedence and associativity is left to right\n<eos>"
    },
    {
        "key": "merged_topic_19_0",
        "label": "satisfied, loop, body, looping, condition, stopping, terminate, problem, algorithm",
        "input": "<task:merge> <sos>\nDecision making and looping Looping ( or iteration ) is the process of executing a sequence of statements until some condition for termination of loop is satisfied\nIf the conditions are not satisfied then the body of the loop will not be executed\nIf the condition is true the program continues to evaluate the body of the loop once again\nIf the condition is true the body of loop is executed otherwise the loop is terminated and execution continues with the statement that immediately follows the loop\nIf the condition is satisfied the body of the loop is again executed\n\n++++\n\nAfter performing the instructions that is after the algorithm terminates the desired results must be obtained\nStep Stop ( End ) The above mentioned example is simpler one but development of an algorithm of a complex problem is very difficult\nSometimes it becomes necessary to come out of the loop even before the loop condition becomes false\nIn such a situation break statement is used to terminate the loop\nThis statement causes an immediate exit from that loop in which this statement appears\nThe loop does not terminate when a continue statement is encountered\nJumping completely out of the loop under certain conditions terminating the execution of a loop\nProblem statement must include a stopping condition ie\nThe problem can be solved in this manner for any value of n greater than ( n represents a stopping condition )\n<eos>"
    },
    {
        "key": "merged_topic_20_0",
        "label": "function, calling, return, does, receive, recursive, calls, temperature, satisfied, recursion",
        "input": "<task:merge> <sos>\nVoid data type ( for empty set of value and nonreturning functions ) the void type specifies an empty set of values\nIt is used as the return type for functions that do not return a value\nFunction with no arguments and no return values When a function has no argument it does not receive any data from the calling function\nSimilarly when it does not return value the calling function does not receive any data from the called function\nFunction with no argument and return type In this function the function does not take any input from the calling function but it returns value to the calling function\nRecursive A function is said to be recursive if a statement in the body of the function calls itself\nThe return statement is necessary only when the function is returning some data back to the calling function\n\n++++\n\nFor example inlcude main ( ) int c double d crlscr ( ) printf ( Enter temperature in Celsius ) scanf ( d c ) d convert ( c ) Function call printf ( The Fahrenheit temperature of d C lf Fc d ) getch ( ) double convert ( int C ) function definition double f f c return f What is about main ( ) function\nmain ( ) register int a Recursive Function Recursion in programming is a technique for defining a problem in terms of one or more smaller versions of the same problem\nA recursive function is one that calls itself directly or indirectly to solve a smaller version of its task until a final call which does not require a selfcall\nThus the function is called recursive function if it calls to itself and recursion is a process by which a function call itself repeatedly until some specified condition will be satisfied\nTo solve a problem using recursive method two conditions must be satisfied\nwe must have an if statement somewhere to force the function to return without the recursive call being executed otherwise function will never return\nWhat is a recursive function\n<eos>"
    },
    {
        "key": "merged_topic_21_0",
        "label": "prototype, declaration, local, function, global, definition, body, display, int",
        "input": "<task:merge> <sos>\nFunction declaration or Function prototype\nFunction Prototype A function prototype is a declaration of the function that tells the program about the type of the value returned by the function and the number and type of each argument\nFunctiontype functionname ( parameter list ) Example void sum ( int a int b ) when we place the declaration above all the function ( in the global declaration section ) the prototype is referred to as global prototype\nWhen we place it in a function definition ( in the local declaration section ) the prototype is called a local prototype\nThe prototype declaration should be similar to the function header\n\n++++\n\nFor example int add ( int int ) int add ( int a int b ) void display ( int a ) void display ( int ) Function definition A function definition is a group of statements that is executed when it is called from some point of the program\nstatements is the functions body\nThe first line of the function definition is known as function header\nThis statement can appear anywhere inside the body of the function\nFormal Actual When a function is called some parameters are written within parenthesis\nWhat is a function\nWhen we call the function no need to subscript or square brackets\n<eos>"
    },
    {
        "key": "merged_topic_22_0",
        "label": "function, calling, return, does, receive, parameter, type, returned, mul",
        "input": "<task:merge> <sos>\nVoid data type ( for empty set of value and nonreturning functions ) the void type specifies an empty set of values\nIt is used as the return type for functions that do not return a value\nFunction with no arguments and no return values When a function has no argument it does not receive any data from the calling function\nSimilarly when it does not return value the calling function does not receive any data from the called function\nFunction with no argument and return type In this function the function does not take any input from the calling function but it returns value to the calling function\nRecursive A function is said to be recursive if a statement in the body of the function calls itself\nThe return statement is necessary only when the function is returning some data back to the calling function\n\n++++\n\nThe general syntax of function prototype is return_type function_name ( type type typen ) where return_type specifies the data type of the value returned by the function\nA function can return value of any data type\nThe general syntax is return_type function_name ( parameter parameter parametern ) statements where return_type is the data type specifier of data returned by the function\nThe syntax of teh call if function return_type is void is function_name ( parameter name ) If function return int float or any other type value then we have to assign the call to same type value like variable function_name ( parameter ) For example m mul ( x y ) The type of m is same as the return type of mul function\nThis type of function is defined as void function_name ( ) body of function The keyword void means the function does not return any value\n<eos>"
    },
    {
        "key": "merged_topic_23_0",
        "label": "function, calling, return, does, receive, sum, arguments, func",
        "input": "<task:merge> <sos>\nVoid data type ( for empty set of value and nonreturning functions ) the void type specifies an empty set of values\nIt is used as the return type for functions that do not return a value\nFunction with no arguments and no return values When a function has no argument it does not receive any data from the calling function\nSimilarly when it does not return value the calling function does not receive any data from the called function\n\n++++\n\nint addition ( int a int b ) function prototype main ( ) int addition ( ) function call printf ( The result isdz ) int addition ( int a int b ) function header int r r ab return r Output The result is return statement The return statement is used in a function to return a value to the calling function\nProgram to understand the use of return statement include void funct ( int float ) main ( ) int age float ht clrscr ( ) printf ( Enter age and height ) scanf ( df age ht ) funct ( age ht ) getch ( ) void funct ( int age float ht ) if ( age ) printf ( Age should be less than n ) return if ( ht ) printf ( Height should be more than n return print ( selected n ) The second form of return statement is used to terminate a function and return a value to the calling function\nFor example return return ( xyz ) return ( sum ( ab ) ) Calling a function ( or A calling function ) A function can be called by specifying its name followed by a list of arguments enclosed in parenthesis and separated by commas in the main ( ) function\nFunctions with no arguments and no return value\nFunctions with no arguments and a return value functions with arguments and no return value Functions with no arguments and no return value When a function has no arguments it does not receive any data from the calling function\n<eos>"
    },
    {
        "key": "merged_topic_23_1",
        "label": "function, calling, return, does, receive, sum, arguments, func",
        "input": "<task:merge> <sos>\nFunction with no argument and return type In this function the function does not take any input from the calling function but it returns value to the calling function\nRecursive A function is said to be recursive if a statement in the body of the function calls itself\nThe return statement is necessary only when the function is returning some data back to the calling function\n\n++++\n\nProgram to illustrate the function with no arguments and no return values void add ( ) int a b sum printf ( n Enter two numbers t ) scanf ( dd a b ) sum a b printf ( n The sum is d sum ) void main ( ) clrscr ( ) add ( ) getch ( ) Output Enter two numbers The sum is Functions with no arguments and a return value These type of functions do not receive any arguments but they can return a value\nint func ( void ) main ( ) int r int func ( void ) return ( expressions ) Program to illustrate function with no argument and a return value inlcude int add ( void ) main ) printf ( The sum is dn add ( ) ) int add ( void ) int n n sum printf ( Enter two numbers t ) scanf ( dd n n ) sum nn return ( sum ) Output Enter two numbers The sum is Functions with arguments and no return values These types of functions have arguments hence the calling function can send data to the called function but the called function does not return any value\n<eos>"
    },
    {
        "key": "merged_topic_24_0",
        "label": "pass, calling, called, function, parameters, reference, passed, mechanism, changed",
        "input": "<task:merge> <sos>\nIn effect there is no data transfer between the calling function and the called function\nIt is a twoway data communication between the calling and called function\nWays of passing arguments to functions There are two different mechanisms to pass arguments to function\nPass by value ( also called as call by value ) Pass by reference ( also known as call by pointer ) Pass by value In pass by value values of actual parameters are copied to the variable in the parameter list of the called function\nThe called function works on the copy and not on the original values of the actual parameters\nThis ensures that the original data in the calling function can not be changed accidently\nIn this case the called function directly work on the data in the calling function and the changed value are available in the calling function for its use\nThis method is also used when we require multiple values to returned by the called function\nLet us consider following example to explain it\n\n++++\n\nThere are some variables that are used in more than one function\nWhen some specific code is to be used more than once and at different places in the program the use of function avoids repetition of that code\nIn function we can pass a variable by two ways\nPass by value ( or call by value )\nPass by reference ( or call by reference ) Function call by value In this the value of actual parameter is passed to formal parameter when we call the function\nits value persists between different function calls\nWhen we pass array that pass as a call by reference because the array name is address for that array\nAs address is passed in this case this mechanism is also ka call by address or call by reference\nAs address of variable is passed in this mechanism if value in the passed address is changed within function the value of actual variable also changed\n<eos>"
    },
    {
        "key": "merged_topic_25_0",
        "label": "pointer, tells, slide, asterisk, unrelated, address, price, equivalent, variable",
        "input": "<task:merge> <sos>\nPointer refer to book for proper knowledge as this content is from class note slide Declaring Pointer Variables Syntax data_type pt_name This tells the compiler three things about the variable pt_name\nThis asterisk ( ) tells that the variable pt_name is a pointer variable\npt_name needs a memory location\npt_name points to a variable type of data_type\nHowever any comparisons of pointer that refers to separate and unrelated variables make no sense\nSimilarly two pointer can not be added\n\n++++\n\nThus pointer variables are defined as int a float b char c where a b c are pointer variable which stores address of integer float and char variable\nProgram to print address of variable using include main ( ) int sn float price printf ( value of snd Address of snun sn sn ) printf ( value of pricef Address of priceun price price ) output value of sn Address of sn value of price Address of price Pointer Fundament Pointer Declaration Introduction A pointer is a variable that contains a memory address of data or another variable\nThe asterisk preceding this name informs the compiler that the variable is declared as a int iptrsn float fptrprice iptrsn assigning of pointer fptrprice Now iptr contains the address of variable sn ie\nit points to variable sn similarly fptr points to variable sn similarly fptr points variable price\nIf pointers are declare after the variable like int snpsn float priceqprice It is also possible to assign the value of one pointer variable to the other provided their base type is some\nPP Now both pointer variable P and P contains the address of variable sn and points the same variable iptr sn fptr P sn P We can also assign constant zero to a pointer of any type\n<eos>"
    },
    {
        "key": "merged_topic_26_0",
        "label": "file, opening, data, defined, secondary, mode, opened, fopen, open",
        "input": "<task:merge> <sos>\nThe basic file operations performed are Naming a file Opening a file Reading data from a file Writing data from a file Closing a file\nDefining and opening a file If we want to perform operation in a file in the secondary memory we must specify certain things about the file to the operating system\nExample Studenttxt Employdat Data structure of a file is defined as FILE in the library of standard IO function definitions\nTherefore all files should be declared as type FILE before they are used\nFILE is a defined data type\nFor example we may write data to the file or read the already existing data\nFollowing is the general format for declaring and opening a file FILE fp fp fopen ( filenamemode ) the first statement declares the variable fp as a pointer to the data type FILE\nThe second statement opens the file named filename and assigns an identifier to the FILE type pointer fp\n\n++++\n\nfp fopen ( argv w ) opens a file with name TEXT\nThe function fopen ( ) is used to open a file\nOn success fopen ( ) returns a pointer of type FILE and on error it returns NULL\nFor example FILE fp fp fp fopen ( myfiletxt w ) fp fopen ( yourfiledat r ) The file opening mode specifies the way in which a file should be opened ( ie\nTo open a file in binary mode we can append b to the mode and to open the file in text mode t can be appended to the mode\nBut since text mode is the default mode t is generally omitted while opening files in text mode\nFor example wb Binary file opened in write mode ab or ( ab ) Binary file opened in append mode rt or ( rt ) Text file opened in update mode w or ( wt ) Text file opened in write mode The file that was opened using fopen ( ) function must be closed when no more operations are to be performed on it\n<eos>"
    },
    {
        "key": "merged_topic_27_0",
        "label": "columns, rows, varies, array, number, dimensional, multidimensional, arrays, square",
        "input": "<task:merge> <sos>\nA two dimensional array is the simplest of multidimensional arrays\nFor instance an array A MN is a M by N table with M rows and N columns containing M X N element\nThe number of elements in a D array can be determined by multiplying number of rows with number or columns\nFor example the number of elements in an array A is calculated as X\n\n++++\n\nSquare brackets enclosing the size specification for text\nauto register static or extern ) Single and Multidimension arrays One or single dimensional array There are several forms of an array in Cone dimensional and multidimensional array\nIn one dimensional array there is a single subscript or index whose value refers to the individual array element which ranges form to n where n is the size of the array\nExamples of single dimensional array Program that reads integers from keyboard and displays entered numbers in the screen include main ( ) int a i clrscr ( ) printf ( Enter numbers t ) for ( i i main ( ) float a int i clrscr ( ) printf ( The continuous memory locations are n ) printf ( tu ai ) address of array element getch ( ) Output The continuous memory locations are Program to sort n numbers in ascending order main ( ) int num i j n temp clrscr ( ) printf ( How many numbers are there\nEnter numbers The numbers in ascending order Multidimensional arrays An array of arrays is called multidimensional array\nFor example a one dimensional array of one dimensional array is called two dimensional array\nA one dimensional array of two dimensional arrays is called three dimensional arrays etc\nDeclaration of two dimensional array Multidimensional arrays are declared in the same manner as one dimensional array except that a separate pair of square brackets are required for each subscript ie\ntwo dimensional array requires two pair of square bracket three dimensional array requires three pairs of square brackets four dimensional array require four pair of square brackets etc\n<eos>"
    },
    {
        "key": "merged_topic_27_1",
        "label": "columns, rows, varies, array, number, dimensional, multidimensional, arrays, square",
        "input": "<task:merge> <sos>\nN AN Row M A The general form of a twodimensional array is type arraynamerow_sizecolumn_size Where type is the data type of the array having name arrayname row_size the first index refers to the number of rows in the array and column_size the second index refers to the number of columns in the array\nFor example consider a two dimensional array A ( IJ ) where I varies from to and J varies from to\n\n++++\n\nFor example int n float a static char line double add Initialization of multidimensional array Similar to one dimensional array multidimensional array can also be initialized\n<eos>"
    },
    {
        "key": "merged_topic_28_0",
        "label": "matrix, print, enter, column, array, dimensional, multidimensional, arrays, square",
        "input": "<task:merge> <sos>\nStore the sum of A and B in C\nPractice Write to program to arrange list of elements in ascending order include include include void main ( ) int ntemp int ij printf ( nEnter the list of elements ) for ( iinj ) tempni ninj njtemp printf ( n The elements in assending order ) for ( iii ) printf ( ndni ) getch ( ) Two Dimensional Array A twodimensional array is an array in which each element is itself an array\nPractice Write a program that adds the individual rows of a two dimensional array of m by n and store the sums of rows into a single dimensional array using functions\nWrite a function that takes a two dimensional array and onedimensional array and process the result and store in onedimensional array\n\n++++\n\nSquare brackets enclosing the size specification for text\nauto register static or extern ) Single and Multidimension arrays One or single dimensional array There are several forms of an array in Cone dimensional and multidimensional array\nIn one dimensional array there is a single subscript or index whose value refers to the individual array element which ranges form to n where n is the size of the array\nExamples of single dimensional array Program that reads integers from keyboard and displays entered numbers in the screen include main ( ) int a i clrscr ( ) printf ( Enter numbers t ) for ( i i main ( ) float a int i clrscr ( ) printf ( The continuous memory locations are n ) printf ( tu ai ) address of array element getch ( ) Output The continuous memory locations are Program to sort n numbers in ascending order main ( ) int num i j n temp clrscr ( ) printf ( How many numbers are there\nEnter numbers The numbers in ascending order Multidimensional arrays An array of arrays is called multidimensional array\nFor example a one dimensional array of one dimensional array is called two dimensional array\n<eos>"
    },
    {
        "key": "merged_topic_28_1",
        "label": "matrix, print, enter, column, array, dimensional, multidimensional, arrays, square",
        "input": "<task:merge> <sos>\nMatrix Multiplication include include void input ( int aint rint c ) int ij for ( iiri ) for ( jjcj ) scanf ( daij ) void display ( int aint rint c ) int ij for ( iiri ) for ( jjcj ) printf ( daij ) printf ( n ) void multiply ( int aint bint cint rint cint c ) int ijk for ( iiri ) for ( jjcj ) cij for ( kkck ) cijaikbkj void main ( ) int abcrrcc clrscr ( ) printf ( nEnter the row and column for first matrix ) scanf ( ddrc ) printf ( nEnter the row and column for second matrix ) scanf ( ddrc ) if ( cr ) printf ( nMultipication is not possible ) else printf ( nenter the value to first matrix ) input ( arc ) printf ( nenter the value to second matrix ) input ( brc ) multiply ( abcrcc ) printf ( n The resultant Matrix is ) display ( crc ) getch ( ) Passing string to functions The string are treated as character array in C and therefore the rules of passing string to function are very similar to those for passing array to functions\nWRITE ( ) ( A ( I ) I ) PRACTICE Write a program to take input to one dimensional array and display\nINTEGER IN ( ) PRINT ENTER THE ELEMENTS TO ARRAY READ ( ) ( IN ( I ) I ) PRINT THE ELEMENTS OF ARRAY IS WRITE ( ) ( IN ( I ) I ) STOP END Write a program to arrange one dimensional array in ascending order in FORTRAN\nPRACTICE Write a program to take input and display two dimensional arrays\n\n++++\n\nA one dimensional array of two dimensional arrays is called three dimensional arrays etc\nDeclaration of two dimensional array Multidimensional arrays are declared in the same manner as one dimensional array except that a separate pair of square brackets are required for each subscript ie\n<eos>"
    },
    {
        "key": "merged_topic_28_2",
        "label": "matrix, print, enter, column, array, dimensional, multidimensional, arrays, square",
        "input": "<task:merge> <sos>\nC input and display elements OF MATRIX INTEGER IN ( ) PRINT ENTER THE ELEMENTS TO ARRAY READ ( ) ( ( IN ( IJ ) J ) I ) PRINT THE ELEMENTS OF ARRAY IS WRITE ( ) ( ( IN ( IJ ) J ) I ) STOP END Write a program to add two matrixes and display the resultant matrix in FORTRAN\nC ADDING CORRESPONDING ELEMENT OF TWO MATRIX TO THIRD MATRIX INTEGER A ( ) B ( ) C ( ) RRCC PRINT ENTER THE ROW AND COLUMN OF FIRST MATRIX READ RC PRINT ENTER THE ROW AND COLUMN OF SECOND MATRIX READ RC IF ( ( REQR ) AND\n\n++++\n\ntwo dimensional array requires two pair of square bracket three dimensional array requires three pairs of square brackets four dimensional array require four pair of square brackets etc\nFor example int n float a static char line double add Initialization of multidimensional array Similar to one dimensional array multidimensional array can also be initialized\n<eos>"
    },
    {
        "key": "merged_topic_29_0",
        "label": "index, base, address, arrayindex, noriginal, local, swap, prints, stored",
        "input": "<task:merge> <sos>\nIdentifiers refer to the name of variables functions and arrays\nIn c arrays index numbering starts with\nExample include include void main ( ) int xbx int yay int z clrscr ( ) printf ( nEnter the value ) scanf ( dx ) printf ( nEnter the value ) scanf ( dy ) zxyab printf ( nThe value of z isdz ) printf ( nOriginal value of b is ub ) b printf ( nChanged value of b is ub ) printf ( nOriginal value of a is ua ) aa printf ( nChanged value of a is ua ) getch ( ) Pointer and Arrays When an array is declared the compiler allocate a base address and sufficient amount of storage to contain all the elements of the array in contiguous memory allocation\nThe base address is the location of the first element ( index ) of the array\nThe compiler also defines the array name as a constant pointer to the first element\n\n++++\n\nint x float y char c a x the address of x is assigned to pointer variable a b y the address of y is stored to pointer variable b c c the address of c is stored to pointer variable c include void swap ( int int ) function prototype main ( ) int x y x clrscr ( ) swap ( x y ) function call by address printf ( xdn x ) printf ( ydn y ) getch ( ) void swap ( int a int b ) int t t a a b b t Output x y PU Concept of Local Global Static variables Local variables ( automatic or internal variable ) The variables that are defined within the body of a function or a block are local to that function or block only and are called local variables\nAddress operator ( ) C provides an address operator which returns the address of a variable when placed before it\nThe following program prints the address of variabvles using address operator\n<eos>"
    },
    {
        "key": "merged_topic_29_1",
        "label": "index, base, address, arrayindex, noriginal, local, swap, prints, stored",
        "input": "<task:merge> <sos>\nSuppose we declare an array x as follows int x Suppose the base address of x is then Element x x x x x Value Address Example Heres the array version include include void main ( ) int a int i clrscr ( ) for ( iii ) printf ( nd uaiai ) getch ( ) Now lets see how this program would look using pointer notation\n( array index ) is the same as arrayindex\n( array index ) is the same as arrayindex Pointer to Array in Function As an example to explain that a program where each element of array will be added by a constant\n\n++++\n\nLet us take an example int a float b intP a floatp b In above program if we place before P when we can access the variable whose address is stored in P\nFor example int aP Pa After statement pa p point the array ie\nthe p contains the address of a ( first address of array ) P After this statement P points to a element\nWhen i then ( pi ) is ( p ) means p therefore this prints the value which store at location P Similarly ( p ) means the value of second element because p is pointer to the second element of array\np contains the address of element ) or p is name of array\n<eos>"
    },
    {
        "key": "merged_topic_30_0",
        "label": "loop, exitcontrolled, tested, entrycontrolled, control, body, executed, condition, statements",
        "input": "<task:merge> <sos>\nEntryControlled loop In entrycontrolled loop the control conditions are tested before the start of the loop execution\nExitControlled loop In exitcontrolled loop the test is performed at the end of the body of the loop and therefore the body is executed unconditionally for the first time\nWhen the body of the loop is executed the control is transferred back to the for statement after the evaluating the last statement in the loop\nNow the control variable is incremented using as assignment statement such as ii and the new value of the control variable is again tested to see whether it satisfies the loop condition\n\n++++\n\nThis ensures that the algorithm will ultimately terminate\nSo a loop may be defined as a block of statements which are repeatedly executed for a certain number of times or until a particular condition is satisfied\nThe control statement in loop decides whether the body is to be executed or not\nAfter the execution again the condition is checked and if it is found to be true then again the statements in the body of loop are executed\nThe body of this loop may contain a single statement or a block of statements\nIf the condition is true then again the loop body is executed and this process continues until the condition becomes false\nInstead the remaining loop statements are skipped and the computation proceeds directly to the next pass through the loop\n<eos>"
    },
    {
        "key": "merged_topic_31_0",
        "label": "statement, condition, expression, switch, statements, case, choice, default",
        "input": "<task:merge> <sos>\nrespectively Decision making and Branching C language possesses such decisionmaking capabilities by supporting the following statements if statement switch statement conditional operator statement goto statements These statements are known as decisionmaking statements\nif statement It takes the following form if ( test expression ) It allows the computer to evaluate the expression first and then depending on whether the value of the expression ( relation or condition ) is true ( non zero ) or false ( zero ) it transfers the control to a particular statement\nThis point of program has two paths to follow one for the true condition and the other for the false condition Entry False True The ifelse statement The general form is if ( test expression ) Trueblock statement ( s ) else Falseblock statement ( s ) statementx if the test expression is true then the trueblock statement ( s ) immediately following the if statements are executed otherwise the falseblock statement ( s ) are executed\nIn either case trueblock or falseblock will be executed not both\nTrueblock statement Falseblock statement Statement x Nesting of ifelse statement The general form is if ( test condition ) if ( test condition ) statement else statement else statement statementx The else if ladder A multipath decision is a chain of ifs in which the statement associated with each else is an if\nIt takes the following general form if ( condition ) statement else if ( condition ) statement else if ( condition ) statement else if ( condition n ) statementn else defaultstatement statementx The switch statement The switch statement tests the value f a given variable ( or expression ) against a list of case values and when a match is found a block of statements associated with that case is executed\n\n++++\n\nFor making this choice we use the switch statement\nThe general syntax is switch ( expression ) case constant statements break case constantN statements break default statements Here switch case and default are keywords\n<eos>"
    },
    {
        "key": "merged_topic_31_1",
        "label": "statement, condition, expression, switch, statements, case, choice, default",
        "input": "<task:merge> <sos>\nThe general form of the switch statement is as shown below switch ( expression ) case value block break case value block break default defaultblock break statementx The expression is an integer expression or characters\nblock blockare statement lists and may contain zero or more statements\nThe general form is If ( expression ) nnn Where ( expression ) is a valid FORTRAN arithmetic expression enclosed within parenthesis\nThe general form of the statement is IF ( condn ) Statement Where condn is a logical condition statement is an executable statement\nThe general form of the statement is IF ( condn ) THEN S S ELSE S S ENDIF Where condn is a logical condition SS are the statement to be executed when cond is true SS are the statement to be executed when cond is false\n\n++++\n\nThe expression following the switch keyword can be any C expression that yields an integer value or a character value\nWriting a switch statement inside another is called nesting of switches\nFirstly the switch expression is evaluated then value of this expression is compared one by one with every case constant\nIf none of the case constant matches with the value of the expression then the block of statements under default is Flowchart switch ( expression ) case constant ( expression constant ) Body of case constant case constant ( expression constant ) Body of case constant case N default default Out of switch fig Flowchart of switch statement Program to understand the switch control statment include main ( ) int choice clrscr ( ) printf ( Enter your choice ) scanf ( d choice ) switch ( choice ) case case printf ( secondn ) case printf ( thirdn ) default printf ( wrong choicen ) getch ( ) Output Enter your choice Second Third Wrong Choice Here value of choice matches with second case so all the statements after case are executed sequentially\nWrite a menu driven program using switch statement having the following options\n<eos>"
    },
    {
        "key": "merged_topic_32_0",
        "label": "starting, variable, integer, letters, ijklm, root, declarations, contains, short, long",
        "input": "<task:merge> <sos>\nVariable definitions The statement datatype variable_name eg\nint atotal Defining a variable tells the compiler the name of the variable and the type of variable\nAn identifier declared as int becomes an integer variable and can hold integer value only\nAn identifier declared as float becomes a floatingpoint variable and can hold floatingpoint number only\nThis is done as follows register auto int a Most compilers allow only int or char type variable to be placed in register\nIf the variables are not declared the variable names starting with letters IJKLM or N are considered to be integer variable and other as real variables\nThe general format for declaring integer variables is shown below INTEGER list of variables Eg\nExample IMPLICIT INTEGER ( A ) The above statement declares that all the variable name starting with the alphabet A are integer variables\n\n++++\n\nThe standard keywords are auto break case char const continue default do double else enum extern float for goto if int long register return short signed sizeof static struct switch typedef union unsigned void volatile while The keywords are all lowercase\nA C program contains the following lines char d a b c a b d a a b c a b d w The first two lines are not type declaration which state that a b and c are integer variables and that d is a character type\nA C program contains the following type declarations int a b c float root root char flag text Thus a b and c are declared to be integer variables root and root are floating variables flag is a chartype variable and text is an element chartype array\nThese declarations could also have been written as follows int a int b int c float root float root char flag char text A C program contains the following type declarations short int a b c long int r s t int p q Also written as short a b c long r s t int p q short and short int are equivalent as are long and long int\n<eos>"
    },
    {
        "key": "merged_topic_32_1",
        "label": "starting, variable, integer, letters, ijklm, root, declarations, contains, short, long",
        "input": "<task:merge> <sos>\nThis does not affect the general rule that the variables starting with the letters IJKLM or N are also integer variable\nSo the above statement declare that all the variable starting with the letters AIJKLM or N are integer variable in the program\n\n++++\n\nA C program contains the following type declarations float c c c double root root also written as long float root root A C program contains the following type declarations\nint c char star float sum Thus c is an integer variable whose initial value is star is a char type variable initially assigned the character sum is a floating point variable whose initial value is and factor is double precision variable whose initial value is\nA C program contains the following type declarations\n<eos>"
    },
    {
        "key": "merged_topic_33_0",
        "label": "pointer, operator, subtract, integers, operators, operand, operands, requires",
        "input": "<task:merge> <sos>\nC operators can be classified into a number of categories\nSpecial operators C support some special operators of interest such as comma operator sizeof operator pointer operator ( and ) and member selection operator (\nExample X ( int ) ie is converted to integer by truncation Operator precedence and associativity Precedence is used to determine how an expression involving more than one operator is evaluated\nExample int a int pa Pointer Expression C allows us to add integers to or subtract integers from pointers as well as to subtract one pointer from another\nPppp In addition to arithmetic operations discussed pointer can also be compared using the relational operators\nWe may no use pointer in division or multiplication\nPointer increment and scalar factor When we increment a pointer its value is increased by the length of the data type that it points to\n\n++++\n\nSome operators require two operands while other act upon only one operand\nMost operators allow the individual operands to be expressions\nA few operators permit only single variable as operand\nThe operands acted upon by arithmetic operators must represent numeric values\nThe remainder operator ( ) requires that both operands be integers and the second operand be non zero\nSimilarly the division operator ( ) requires that the second operand be nonzero\nThe operation always result in a truncated quotient ( ie\na x y delta sum ab area length width Assignment operator and equality operator are distinctly different\nThese operators can not be used in place of one another\nThe operand used with each of these operators must be a single variable\n<eos>"
    },
    {
        "key": "file1_topic_34",
        "label": "software, application, computer, disk, users",
        "input": "<task:clean> <sos>\nComputer Software The software is what really gives the computer life\nSoftware is installed onto your computer and stored in mass storage devices\nSoftware can actually be placed into two separate categories system of applications\nSystem software System software ( popularly called the operating system ) is the foundation software for a computer\nAn operating system ( OS ) controls all parts of the computer\nThe major functions of the OS ate to handle all input devices ( keyboard mouse disk ) handle all output devices ( screen printer disk ) coordinate and manage use of other resources ( memory disk CPU etc\n) accept commands from users provide an environment over which other programs ( software ) can run\nExamples of popular OS are DOS ( Disk Operating System ) Windows Unix Linux OS and Solaris etc\nSome of these OSes are specific to a particular computer system eg\nSolaris runs on Sun SPARC machines\nApplication software Application software is the software that is developed for a particular use\nThese software run over the environment provided by the system software\nThere are thousands of application software\nThere are other utility programs that check if the units inside your machine are functioning properly as they should\nExamples are the disk scanner that checks if the surface of your disks are damaged antivirus that checks if your computer has been infected with some virus ( a malicious program that may just annoy you or even delete all the content of your hard drive ) and clean if found etc\nProblem solving using Computers Standard software packages available in the market are intended for generalpurpose applications\nHowever the users often require customtailored software for performing specific data processing or computational tasks\nApplication software development is the process of creating such software which satisfies the end users requirements and needs\nIn simple language it can be said that problem solving using computers is the development of the application software\nFollowing steps needs to be followed for developing the application software\n<eos>"
    },
    {
        "key": "file1_topic_35_0",
        "label": "step, sum, goto, stop, series",
        "input": "<task:clean> <sos>\nSpreadsheets very simply put gives you when you input\nFor example Read numbers form user and display the resulting sum\nWrite an algorithm and a flowchart to read a five number and check whether the number is a palindrome or not\nAlgorithm Step Start Step Declare variable n r sum i Step i Step Repeat steps Step to until i is less than or equal to else goto step Step input to n Step sum Step tempn Step Repeat Steps to until n is greater than else goto step Step rn mod of Step sumsumr Step nn then goto Step Step if sum is equal to temp than goto Step else goto Step Step Display n as palindrome then goto step Step Display n is not palindrome Step ii then goto step Step Stop Flowchart False True True False True False Start Declare n r sum i i ii Is i\nInput to n Stop sum tempn Is n\nr n mod of sumsumr nn Is tempsum\nDisplay P li d Display Source code include include void main ( ) int nirsumtemp i clrscr ( ) while ( i ) rn sumsumr nn if ( sumtemp ) printf ( Palindrome dtemp ) else printf ( Not Palindrome dtemp ) i getch ( )\nWrite a program to evaluate the following series using recursive function\nn include include float sum int sign void add ( int nint i ) int term if ( in ) signsign termiisign sumsumterm add ( ni ) else printf ( n The sum of series is fsum ) void main ( ) int n printf ( nEnter the number of term ) scanf ( dn ) add ( n ) getch ( ) Static variable A variable can be declared static using the keyword static like static int a Internal static variable are those which are declared inside a function\n<eos>"
    },
    {
        "key": "file1_topic_35_1",
        "label": "step, sum, goto, stop, series",
        "input": "<task:clean> <sos>\nPRACTICE XXX C SERIES USING ARITHMETIC IF INTEGER P PRINT ENTER THE VALUE OF N AND X READ NX I P SUM IF ( IN ) SUMSUMXP PP II GOTO PRINT SUM IS SUM STOP END Logical IF statement The logical if condition checks any given logical condition and transfer the control accordingly\nLogical Condition The following are the relational operators and their symbols used in FORTRAN PRACTICE Write a program to display FIBNOACCI series until term value is less than in FORTRAN\nC FIBONACCI SERIES INTEGER FST PRINT ENTER THE NUMBER OF TERMS F S WRITE ( ) FS TFS IF ( TGT ) GOTO WRITE ( ) T FS ST GOTO STOP END IFTHENELSE statement The IFTHENELSE statement is more useful and easy to handle than the logical if statement\nELSEIF PRACTICE Write a program to display Fibonacci series up to N term in FORTRAN\nC FIBONACCI SERIES INTEGER FST PRINT ENTER THE NUMBER OF TERMS READ ( ) N F S IF ( NEQ ) THEN WRITE ( ) F ELSE WRITE ( ) FS DO IN TFS WRITE ( ) T FS ST CONTINUE ENDIF STOP END Write a program to find the HCF for any two number entered by user in FORTRAN C WRITE A PROGRAM TO FIND HCF ( GREATEST COMMON FACTOR ) READ II IRIIII IF ( IREQ ) THEN PRINT THE HCF ISI STOP ENDIF II IIR GOTO STOP END Nested IFTHENELSE In certain cases we may have to use one IFTHENELSE structure within another IFTHEN\nELSE ENDIF Write a program to check whether a given number is Armstrong or not in FORTRAN\nC PROGRAM TO FIND ARMSTRONG NUMBER OR NOT PRINT ENTER THE NUMBER READ N TEMPN SUM IF ( NGT ) THEN IRNN SUMSUMIR NN GOTO ENDIF IF ( SUMEQTEMP ) THEN PRINT TEMPIS ARMSTORNG ELSE PRINT TEMPIS NOT ARMSTRONG ENDIF STOP END DO LOOPS The DO LOOP is used whenever a particular job is to be repeated number of times\n<eos>"
    },
    {
        "key": "file1_topic_35_2",
        "label": "step, sum, goto, stop, series",
        "input": "<task:clean> <sos>\nIf vv then stop otherwise go to step PRACTICE C PRIME NUMBER INTEGER COUNT READ NUM COUNT DO INUM IF ( MOD ( NUMI ) EQ ) THEN COUNTCOUNT ENDIF CONTINUE IF ( COUNTEQ ) THEN PRINT NUMIS PRIME ELSE PRINT NUMIS NOT PRIME ENDIF STOP END Rules for subscripted variables The following rules may be strictly followed while defining the subscripted variables\nPRINT ENTET THE VALUE OF N AND X READ NX P SIGN FACT SUM DO IN SIGNSIGN DEN DO JFACT DENDENJ CONTINUE NUMSIGNXP SUMSUMNUMDEN FACTFACT PP CONTINUE PRINT THE SUM ISSUM STOP END Additional Topic Look for Preprocessor and Dynamic Memory Allocation\n<eos>"
    },
    {
        "key": "file1_topic_36",
        "label": "large, console, volumes, oriented, data",
        "input": "<task:clean> <sos>\nDatabases are most useful for organizing data\nFor example database software can keep track of your friends name address telephone numbers and you can add or remove whenever you want\nYou need to be sure that the source of the data is consistent so that the date will be available in the future when you need it\nThese are console oriented IO functions which always use the terminal ( keyboard and screen ) as the target place\nThis works fine as long as the data is small\nHowever many real life problems involve large volumes of data and in such situations the console oriented IO operations pose two major problems\nIt becomes cumbersome and time consuming to handle large volumes of data through terminals\nThe entire data is lost when either the program is terminated or the computer is turned off\nIt is therefore necessary to have more flexible approach where data can be stored on the disk and read whenever necessary without destroying the data\nThis method employs the concept of files to store data\n<eos>"
    },
    {
        "key": "file1_topic_37",
        "label": "languages, level, high, lowlevel, programming",
        "input": "<task:clean> <sos>\nProgramming languages are mainly categorized into two types low level and high languages\nLowlevel language A lowlevel language is a programming language much closer to the hardware\nHigh Level Language A high level language is a programming language that enables a programmer to write programs more or less independent of a particular type of computer\nSuch languages are considered highlevel because they are closer to human languages and further from machine languages\nThe main advantage of highlevel languages over lowlevel languages is that they are easier to read write and maintain\nThe first highlevel programming languages were designed in the s\nlow level or high level languages )\n<eos>"
    },
    {
        "key": "file1_topic_38_0",
        "label": "code, object, compiler, language, source",
        "input": "<task:clean> <sos>\nThis converting program is called assembler\nThis can be done in two ways by a compiler or interpreter\nCompiler A compiler is a program that translates program ( called source code ) written in some high level language into object code\nThe compiler derives its name from the way it works looking at the entire piece of source code and collecting and reorganizing the instructions\nA compiler translates highlevel instructions directly into machine language and this process is called compiling\nCompile Compiling is a process of transforming a program written in a highlevel programming language from source code into object code\nThe first step is to pass the source code through a compiler which translates the highlevel language instructions in the source code follow its syntax rules\nThe final step in producing an executable program after the compiler has produced object code is to pass the object code through a linker\nThe linker combines molecules ( different program segments ) and gives real values to all symbolic addresses ( memory locations ) thereby producing machine code\nThe compiler translates the source code into a form called object code\nObject code Object code is the code produced by a compiler\nObject code is often the same as or similar to a computers machine language\nThe final step in producing an executable program is to transform the object code into machine languages if it is not already in this form\nA program called linker does this job\nCompilation and Execution Generally coding is done in highlevel language and sometimes in lowlevel language ( such as assembly language )\nIn a compiled language a translation program is run to convert the programmers entire highlevel program which is called the source code into a machine language code\nThis translation process is called compilations\nThe machine language code is called the object code and can be saved and either runs ( executed ) immediately or later\nIn an interpreted language a translation program converts each program statement into machine code just before the program statement is to be executed\n<eos>"
    },
    {
        "key": "file1_topic_38_1",
        "label": "code, object, compiler, language, source",
        "input": "<task:clean> <sos>\nNo object code is stored and there is no compilation\nThis means that in a program where one statement is executed several times ( such as reading and employs payroll record ) that statement is converted to machine language each time it is executed\nThe compilation process The object of the compiler is to translate a program written in a high level programming language from source code to object code\nThe first step is to pass the source code through a compiler which translate the high level language instructions into object code\n<eos>"
    },
    {
        "key": "file1_topic_39",
        "label": "allowed, illegal, pppp, expressions, rule",
        "input": "<task:clean> <sos>\nThis rule is called syntax\nThe expressions such as pppp and pp are allowed\npp or pp or p are not allowed\nie pp Is illegal\n<eos>"
    },
    {
        "key": "file1_topic_40",
        "label": "languages, compiled, cobol, interpreted, compilers",
        "input": "<task:clean> <sos>\nNow there are dozens of different languages such as Ada Algol BASIC COBOL C C FORTRAN LISP Pascal and Prolog etc\nBecause compilers translate source code into object code which is unique for each type of computer many compilers are available for the same language\nFor example there is a C compiler for PCs and another for Unix computers\nThe high level languages can be either called compiled languages or interpreted languages\nSome of the most widely used compiled languages are COBOL C C FORTRAN etc\nUnlike the compiled languages\nThe most frequently used interpreted language is BASIC\n<eos>"
    },
    {
        "key": "file1_topic_41",
        "label": "interpreter, faster, programs, interpreted, interpreters",
        "input": "<task:clean> <sos>\nInterpreter An interpreter translates highlevel instructions into an intermediate form which it then executes\nInterpreter analyzes and executes each line of source code in succession without looking at the entire program the advantage of interpreters is that they can execute a program immediately\nHowever programs produced by compilers run much faster than the same programs executed by an interpreter\nCompiled programs generally run faster than interpreted programs\nThe advantage of an interpreter however is that it does not need to get through the compilation stage during which machine instructions are generated\nThe interpreter on the other hand can immediately execute highlevel programs\nFor this reason interpreters are sometimes used during the development of a program when a programmer wants to add small sections at a time and test them quickly\nCompiler languages are better than interpreted languages as they can be executed faster and more efficiently once the object code has been obtained\nOn the other hand interpreted languages do not need to create object code and so are usually easier to develop that is to code and test\n<eos>"
    },
    {
        "key": "file1_topic_42_0",
        "label": "step, flowchart, algorithm, lines, goto",
        "input": "<task:clean> <sos>\nAlgorithm Development and Flowcharting\nAlgorithm Development and Flowchart ( Program design ) You know you have a problem and have identified it in the program analysis stage\nAlgorithms Algorithms are a verbal or say written form of the program\nIt can be defined as ordered description of instructions to be carried out in order to solve the given task\nBasic Guidelines for writing algorithms\nDescribe everything clearly and explicitly\nImportant Features of Algorithm\nFlowchart One of the most widely used devices for designing programs is the flowchart which graphically represents the logic needed to solve a programming problem\nA programming flowchart represents the detailed sequence of steps needed to solve the problem\nProgram flowcharts are frequently used to visualize the logic and steps in processing\nIn other words its a diagrammatic representation of algorithm\nBasic blocks used for drawing flowcharts Structure Purpose Start Stop Processing Decision making Input Outputs Connector For examples Read numbers form user and display the resulting sum\nFlowchart to find the largest among three entered numbers Y N Y N N Y start Read a b cab Display Stop Start input A B C Is AB Is AC Is BC Print A Print C Print B Stop Coding Writing the program is called coding\nWrite an algorithm and flowchart to generate the following\n<eos>"
    },
    {
        "key": "file1_topic_42_1",
        "label": "step, flowchart, algorithm, lines, goto",
        "input": "<task:clean> <sos>\nAlgorithm Step start Step input to n Number of lines Step Initialize c as Deviation on each line Step i Number of lines Step Repeat step to until i less than or equal to n else goto step Step j Number of column Step Repeat step to until j less than or equal to ( n ) else goto step Step Is j greater than or equal to ( nc ) and less than or equal to ( nc ) than goto Step else goto Step Step Display then goto step Step Display Step jj then goto step Step Display newline Step cc Step ii then goto step Step Stop for ( ii ( nc ) j include void main ( ) int ncij clrscr ( ) c deviation printf ( nEnter the number of lines ) scanf ( dn ) number of lines Flow Chart False True False True True False Start Input to n c ii ( nc ) j ( nc )\n<eos>"
    },
    {
        "key": "file1_topic_43",
        "label": "requirements, specifying, inputs, processing, input",
        "input": "<task:clean> <sos>\nSpecifying the input requirements\nSpecifying the processing requirements\nSpecifying the input requirements Now that you have determined the outputs you need to define the input and data\nTo do this you list the inputs required and the source of the data\nFor example in a payroll program inputs could be employee timesheets and the source of the in put could be either the employees themselves or their supervisors\nSpecifying the processing requirements Now you have to determine the processing requirements for converting the input data to output\nQuantities that have specified relation to inputs\n<eos>"
    },
    {
        "key": "file1_topic_44",
        "label": "positive, symbol, assumed, negative, sign",
        "input": "<task:clean> <sos>\nDo not make any assumptions\nor will precede the signed numeric item\n( with o or x ) causing octal and hex item to be preceded by and x\nCapital alphabetsAZ Digit Symbols\nThe symbol or can occur only at the left most end of the number\nFor negative number symbol is used at the most position and for the positive number symbol is used\nIf no symbol occurs the number is assumed to be positive\nA negative number must be written with the symbol\nFor a positive number the symbol is optional\nIf there is no sign the number is assumed to be positive\nThe exponent is always an integer with at most two digit\nThe exponent can have sign ( or )\nIf there is no sign the exponent is assumed to be positive\nThe subscript is always an integer\nThe subscript value can not be negative\n<eos>"
    },
    {
        "key": "file1_topic_45",
        "label": "containing, implemented, makes, effectiveness, concise",
        "input": "<task:clean> <sos>\nEffectiveness All operations must be sufficiently basic so as to be implemented with even paper and pencil\nIn addition using many of them makes a program logic complicated and renders the program unreadable\nThese enable us to develop concise programs containing repetitive processes without the use of goto statements\nThat is they can not be used for reading a text containing more than one word\n<eos>"
    },
    {
        "key": "file1_topic_46",
        "label": "notation, scanf, field, reads, specified",
        "input": "<task:clean> <sos>\nDisplay the value in C\nIt can be performed using scanf function\nThe general format of scanf is scanf ( control stringargargarnn ) The control string specifies the field format in which the data is to be entered and the arguments arglargargn specify the address of locations where the data is stored\nWhen the scanf reads a particular value reading of the value will be terminated as soon as the number of character specified by the field width is reached ( if specified ) or until a character that is not valid for the value being read in encountered\nFor example scanf ( d d dab ) will assign the data as follows to a skipped ( because of ) to b Inputting Real Numbers Unlike integer numbers the field width of real number is not to be specified and therefore scanf reads real numbers using the simple specification f for both the notation namely decimal point notation and exponential notation\n<eos>"
    },
    {
        "key": "file1_topic_47",
        "label": "keyword, lowercase, colon, underscore, permitted",
        "input": "<task:clean> <sos>\nKeyword All keyword have fixed meaning and these meaning can not be changed\nAll keyword words must be written in lowercase\nBoth uppercase and lowercase letter are permitted although lowercase letters are commonly used\nThe underscore character is also permitted in identifiers\nFirst character must be an alphabet ( or underscore )\nCan not use a keyword\nNote that case labels end with a colon ( ) The\nA label is any valid variable name and must be followed by a colon\nNote only single quote ( ) must be used and not the double quotes ( )\nNo special is allowed in a variable name\nThe subscript must be given within parenthesis after the variable name\n<eos>"
    },
    {
        "key": "file1_topic_48",
        "label": "digits, succeeding, alphabets, character, displays",
        "input": "<task:clean> <sos>\nThese are userdefined names and consist of a sequence of letters and digits with a letter as a first character\nThis statement displays the character contained in the variable_name at the terminal\nVariable name can be form one to six character in length\nThe first character of the variable name must be an alphabet and the succeeding characters can be alphabets or numeric digits\n<eos>"
    },
    {
        "key": "file1_topic_49",
        "label": "symbolic, names, verbs, fortran, naming",
        "input": "<task:clean> <sos>\nThe rules of identifiers\nSymbolic names have the same form as variable names\nA blank space is required between define and symbolic name and between the symbolic name and the constant\nAfter definition the symbolic name should not be assigned any other value within the program by using an assignment statement\nSymbolic names are NOT declared for data types\nRules of naming variable\nFORTRAN verbs which have special meaning in FORTRAN can not be used as variable names\n<eos>"
    },
    {
        "key": "file1_topic_50",
        "label": "sizeof, const, size, returns, modified",
        "input": "<task:clean> <sos>\nExample const int size const is a new data type qualifier defined by ANSI standard\nThis tells the compiler that the value of the int variable size must not be modified by the program\nThe sizeof operator The sizeof is a compile time operator and when used with an operand it returns the number of bytes the operator occupies\nsizeof ( int ) It returns\nThe size must be integer value or integer constant without any sign\n<eos>"
    },
    {
        "key": "file1_topic_51",
        "label": "conversion, unsigned, signed, type, implicit",
        "input": "<task:clean> <sos>\nIn order to provide some control over the range of number and storage space c has three classes of integer storage namely short int int and long int in both signed and unsigned form\nType Size ( bits ) Range char or signed char to unsigned char to int or signed int to unsigned int to short int or signed short int to unsigned short int to long int or signed long int to unsigned long int to float E to E double E to E long double E to E Operators Operators are words or symbols that cause a program to do something to variable\nType conversion in expression Implicit type conversion C automatically converts any intermediate value to the proper type so that the expression can be evaluated without losing any significance\nThis automatic conversion is known as implicit type conversion\nDuring evaluation it adheres to very strict rules of type conversion\nIf the operands are of different type the lower type is automatically converted to the higher type before the operation proceeds\nThe result is of higher type\nFor example int ab float bc babc the resultant of abc expression is float Explicit Conversion It is the process in which we want to force a type conversion in a way that is different from the automatic conversion\nThe general form of cast is ( typename ) expression Where typename is one of the standard C data type\nImplicit type declaration The general format is given below IMPLICIT type ( ) type ( )\n<eos>"
    },
    {
        "key": "file1_topic_52",
        "label": "precision, double, floatingpoint, point, decimal",
        "input": "<task:clean> <sos>\nFloat data type ( for floatingpoint ) floating point numbers are stored in bits with digit of precision\nDouble data type ( for double precision floating point number ) the data type double is also used for handling floatingpoint numbers\nBut it is treated as a distinct data type because it ( double data type ) occupies twice as much memory as type float and stores floatingpoint numbers with much larger range and precision\nThere is one and only one decimal point\nThis means that there must be one decimal point and there should not be more than one decimal points\n<eos>"
    },
    {
        "key": "file1_topic_53",
        "label": "character, compulsory, string, acquires, byte",
        "input": "<task:clean> <sos>\nChar data type ( for character ) A single character can be defined as a character ( char ) type data\nCharacters are usually stored in bits ( one byte ) of internal storage\nfor character and string\nA string of character is called a character constant\nA variable which acquires only character string is called a character variable\nFor character variables the declaration is compulsory\n<eos>"
    },
    {
        "key": "file1_topic_54",
        "label": "expression, evaluated, relation, conditional, exponentiation",
        "input": "<task:clean> <sos>\nIt is one if the specified relation is true and zero if the relation is false\nWhen postfix ( or ) is used with a variable in an expression the expression is evaluated first using the original value of the variable and then the variable is incremented ( or decremented ) by one\nexpression expression The conditional expression is evaluated first\nIf the result is nonzero expression is evaluated and is returned as the value of the conditional expression\nIt return zero otherwise\nAny expression within parenthesis is first evaluated\nExponentiation is given the top priority and evaluated first in an expression\nThe value of the expression is evaluated first\n<eos>"
    },
    {
        "key": "file1_topic_55",
        "label": "rev, include, int, getch, hcf",
        "input": "<task:clean> <sos>\ninclude include void main ( ) int abl printf ( nEnter two numbers ) scanf ( ddab ) labab printf ( nThe largest number is d l ) getch ( )\n( acac ) ( bcbc ) printf ( nThe largest value is dl ) getch ( ) The goto statement It is the statement to branch unconditionally from one point to another in the program\ninclude include int hcf ( int fint s ) if ( fs ) return s return ( sfs ) void main ( ) int ab clrscr ( ) printf ( nEnter the number ) scanf ( ddab ) printf ( The Hcf is d hcf ( ab ) ) getch ( ) Storage classes The available storage classes are\nReverse a number using recursive function include include void fib ( int ) void main ( ) int n rev ( n ) getch ( ) void rev ( int n ) static int r int d if ( n ) dn rrd nn rev ( n ) else printf ( dr ) Register variable We can tell the compiler that a variable should be kept in one of the machines registers instead of keeping in the memory ( where normal variables are stored )\ninclude include void main ( ) int a int i clrscr ( ) for ( iii ) printf ( nd u ( ai ) ai ) getch ( ) Note\n<eos>"
    },
    {
        "key": "file1_topic_56",
        "label": "comma, expression, simple, combined, closes",
        "input": "<task:clean> <sos>\nThe comma operator The comma operator can be used to link the related expression together\nA comma linked list of expressions are evaluated left to right and the value of rightmost expression is the value of the combined expression\nThe above statement can be equivalently written as int table Commas are require after each brace that closes off a row except in the case of the last row\nThe expression may be any simple variable or structure variable or an expression using simple variables\n<eos>"
    },
    {
        "key": "file1_topic_57",
        "label": "output, blanks, carriage, unwanted, tabs",
        "input": "<task:clean> <sos>\nThis includes RETURN and TAB\nA dummy getchar ( ) may be used to eat the unwanted newline character\nWe can also use the fflush function to flush out the unwanted character\nBlanks tabs or newlines\nBlanks tabs and newlines are ignored\nCarriage control In any output the first character of the output is lost\nThat is considered as the carriage control\nSo the first character of the output must be made a blank space so that the loss does not affect the output\n<eos>"
    },
    {
        "key": "file1_topic_58",
        "label": "string, arguments, control, argn, direct",
        "input": "<task:clean> <sos>\nControl string and arguments are separated by commas\nControl string ( also known as format string ) contain field specification which direct the interpretation of input data\nargn ) Control string consists of three types of items\nEscape sequence character such as nt and b The control string indicates how many arguments follow and what their types are\nThe arguments argargargn are the variables whose values are formatted and printed according to the specifications of the control string\n<eos>"
    },
    {
        "key": "file1_topic_59",
        "label": "format, specification, specifications, sssr, denote",
        "input": "<task:clean> <sos>\nIt may include field ( or format ) specifications consisting of the conversion character a data type character ( or type specifier ) and an optional number specifying the field width\nFormat specifications that define the output format for display of each item\nFORMAT specification When data are to be input or the result to be output we fully mention the type of the data ( integer real or character ) and also its size\nThe specification of the types of the data and its size is called FORMAT specification\nFORMAT statement The general form of a FORMAT statement is n FORMAT ( sssr ) where n is the statement number sssr are the format specifications Rules\nI format The symbol I is used to denote the integer quantities\nThe general I format specification is I w Where w is the width of the integer data\nExample This data can be describe by the format statement FORMAT ( II ) This can be also be written as FORMAT ( I ) F Format The symbol F is used to denote the real data expressed in decimal form\n<eos>"
    },
    {
        "key": "file1_topic_60",
        "label": "break, skip, statement, continue, enclosing",
        "input": "<task:clean> <sos>\nThe break Statement The break statement enables a program to skip over part of the codes\nA break statement terminates the smallest enclosing while dowhile for or switch statement\nThe continue Statement The continue is another jump statement some what like the break statement as both the statement skip over a part of the code\nBut the continue statement is little different from break\nInstead of forcing termination it force the next iteration of the loop to take place skipping any code in between\n<eos>"
    },
    {
        "key": "file1_topic_61",
        "label": "referenced, hold, subscripts, indices, classroll",
        "input": "<task:clean> <sos>\ncc Display Display Array Array is a collection of variables of the same type that are referenced by a common base\nThe array is given a name and its elements are referred by their subscripts or indices\nThe arrayname specifies the name with which the array will be referenced and size defined how many elements the array will hold\narray_nameimember_name Example classroll Practice Define a structure to hold the roll no\n<eos>"
    },
    {
        "key": "file1_topic_62",
        "label": "array, comprised, element, single, behaves",
        "input": "<task:clean> <sos>\nArrays are of different types ( i ) onedimensional array comprised of finite homogeneous element\n( ii ) multidimensional array comprised of elements each of which is itself an array\nSingle dimensional Array The simplest form of an array is a single dimensional array\nAn array definition specifies a variable type and a name along with one more feature size to specify how many data items the array will contain\nThe element value in the list of value must have the same data type as that of type of the array\nAn array is a collection of related data element of same type\nAny array behaves like a builtin data type\n<eos>"
    },
    {
        "key": "file1_topic_63",
        "label": "initialization, size, initialized, dimensional, array",
        "input": "<task:clean> <sos>\nInitialization of one dimensional array After an array is declared its elements must be initialized\nThe general form of initialization of array is type arrayname size list of value The values in the list are separated by commas\nFollowing declares an int array sales of size int sale Initialization two dimensional array Two dimensional arrays are also initialize in the same ways as singledimension ones\nWhen the array is completely initialize with all values explicitly we need not specify the size of first dimension\nIn such cases the size of array will be determined automatically based on the number of elements initialized\n<eos>"
    },
    {
        "key": "file1_topic_64",
        "label": "row, zero, remaining, elements, initialize",
        "input": "<task:clean> <sos>\nExample int number If the number of initializers may be less than the declared size\nIn such case the remaining elements are initialized to zero if the array type is numeric and NULL if the type is char\nExample int num Will initialize the first two elements of num as and respectively and the remaining elements to\nFor example int table initializes the elements of the first row to zero and the second row to one\nThe initialization is done row by row\nThat is int table If the values are missing in an initialize they are automatically set to zero\nint table Will initialize the first two elements of the first row to one the first element of the second row to two and all other elements to zero\nIt permitted to have a partial initialization\nWe can initialize only the first few members and leave the remaining blank\nThe uninitialized members should be only at the end of the list\nThe uninitialized members will be assigned default values as follows Zero for integer and floating point numbers\n<eos>"
    },
    {
        "key": "file1_topic_65",
        "label": "string, char, include, printf, stringi",
        "input": "<task:clean> <sos>\ninclude include void add ( int nint r ) int ij for ( iii ) ri for ( jjj ) rinij void main ( ) int listresultij printf ( nEnter the number ) for ( iii ) for ( jjj ) scanf ( dlistij ) add ( listresult ) printf ( The result is ) for ( iii ) printf ( ndresulti ) getch ( ) String C does not have a string data type rather it implements strings as single dimension character array\nProgram to count number of word in a line\ninclude include include void main ( ) char string int ic clrscr ( ) printf ( n Enter the first string ) gets ( string ) istrlen ( string ) stringi for ( istringii ) if ( stringi ) c printf ( n The number of word in sentencedc ) getch ( ) Array of string An array of string is a twodimensional character array the size of first index ( rows ) determines the number of strings and the size of second index ( column ) determines maximum length of each string\nPass these to a function which reverse the second string and then appends it at the end of the first string\ninclude include char rev ( char name ) int lj char r lstrlen ( name ) for ( lljllj ) rjnamel rj return r void display ( char namechar name ) char n nname This copy the name address to n printf ( n the copy string is sn ) namerev ( name ) strcat ( nname ) printf ( n The new string issn ) void main ( ) char stringstring clrscr ( ) printf ( n Enter the first string ) scanf ( sstring ) printf ( n Enter the second string ) scanf ( sstring ) display ( stringstring ) getch ( ) Structure A structure is a collection of variable ( of different data types ) referenced under one name providing of convenient means of keeping related information together\n<eos>"
    },
    {
        "key": "file1_topic_66",
        "label": "passed, array, passing, formal, argument",
        "input": "<task:clean> <sos>\nPassing Array To Functions Three Rules to pass an array to a function\nFunction must be called by passing only the name of the array\nIn the function definition the formal parameter must be an array type the size of the array does not need to be specified\nThe function prototype must show that the argument in a array\nNote When an entire array is passed as an argument the contents of the array are not copied into the formal parameter array\nInstead information about the addresses of array elements are passed on to the function\nTherefore any changes introduced to the array elements are truly reflected in the original array in the calling function\nHowever this does not apply when an individual element is passed on argument\nThe function must be called by passing only the array name\n<eos>"
    },
    {
        "key": "file1_topic_67",
        "label": "structure, argument, actual, copy, member",
        "input": "<task:clean> <sos>\nWe can not initialize individual members inside the structure template\nThe order of values enclosed in braces must match the order of member in the structure definition\nThe first method is to pass each member of the structure as an actual argument of the function call\nThe general format of sending a copy of a structure to the called function as function_name ( structure_variable_name ) The called function takes the following form data_type function_name ( Struct_type st_name ) return ( expression ) The following points are important to note\nFor example if it is returning a copy of the entire structure then it must be declared as struct with an appropriate tag name\nThe structure variable used as the actual argument and the corresponding formal argument in the called function must be of the same struct type\nWhen a function returns a structure it must be assigned to a structure of identical type in the calling function\n<eos>"
    },
    {
        "key": "file1_topic_68_0",
        "label": "time, distance, struct, printf, sec",
        "input": "<task:clean> <sos>\nPractice Create a structure containing real and imaginary as its member\ninclude include struct complex int r int m void main ( ) struct complex ccc printf ( nEnter the real n imaginary for first complex ) scanf ( ddcrcm ) printf ( nEnter the real n imaginary for second complex ) scanf ( ddcrcm ) crcrcrcmcm cmcrcmcmcr printf ( nThe resultant is ) printf ( nReal is dcr ) printf ( nImaginary is dcm ) getch ( ) Structure and function There are three methods by which the values of a structure can be transferred from one function to another\nPractice Create a structure TIME containing hour minutes and seconds as its member\nWrite a program the uses this structure to input start time and stop time to a function\nWhich returns the sum and difference of the start time and stop time in the main program\ninclude include struct time int hr int min int sec void input ( struct time t ) printf ( nEnter the hr min and sec ) scanf ( dddthrtmintsec ) void display ( struct time t ) printf ( nhrdtmindtsecdtthrtmintsec ) struct time add ( struct time tstruct time t ) struct time t tsectsectsec tmintmintmin thrthrthr tmintsec tsectsec thrtmin tmintmin return t struct time sub ( struct time tstruct time t ) struct time t tsectsectsec tmintmintmin thrthrthr if ( tsec ) tmin tsec if ( tmin ) thr tmintmin return t void main ( ) struct time ttt printf ( nEnter the start time in hr min sec ) input ( t ) printf ( nEnter the stop time in hr min sec ) input ( t ) tadd ( tt ) printf ( naddition of two time is ) display ( t ) tsub ( tt ) printf ( nThe substraction of time is ) display ( t ) getch ( ) Array of Structures We use structure to describe the format of a number of related variables\nBuild functions to add and subtract given distances and display the results in the main function\n<eos>"
    },
    {
        "key": "file1_topic_68_1",
        "label": "time, distance, struct, printf, sec",
        "input": "<task:clean> <sos>\ninclude include struct distance int feet int inch void input ( struct distance d ) printf ( nEnter the feet and inches ) scanf ( dddfeetdinch ) void display ( struct distance d ) printf ( nFeetd t Inchedtdfeetdinch ) struct distance add ( struct distance dstruct distance d ) struct distance d dfeetdfeetdfeet dinchdinchdinch dfeetdinch dinchdinch return d struct distance sub ( struct distance dstruct distance d ) struct distance d dinchdinchdinch dfeetdfeetdfeet if ( dinch ) dfeetdfeet dinchdinch return d void main ( ) struct distance ttt printf ( nEnter the starting distance in feet and inches ) input ( t ) printf ( nEnter the stoping distance in feet and inches ) input ( t ) tadd ( tt ) printf ( naddition of two time is ) display ( t ) tsub ( tt ) printf ( nThe substraction of time is ) display ( t ) getch ( ) Nested Structure Structure within a structure means nesting of structure\n<eos>"
    },
    {
        "key": "file1_topic_69",
        "label": "nonzero, file, pointer, specified, subsequently",
        "input": "<task:clean> <sos>\nThis pointer which contains all the information about the file is subsequently used as a communication link between the system and the program\nIt take a FILE pointer as its only argument and returns a nonzero integer value if all the data from the specified file has been read and return a nonzero integer value if all of the data form the specified file has been read and return zero otherwise\nIt fp is a pointer to file that has just been opened for reading then the statement\nThis means that n bytes have already been read ( or written )\n<eos>"
    },
    {
        "key": "file1_topic_70",
        "label": "rewind, file, remember, position, achieved",
        "input": "<task:clean> <sos>\nIn this mode FILE pointer points to the starting of bite of file\nRandom access to files This can be achieved with the help of the function fseek ftell and rewind available in IO library\nRewind takes a file pointer and resets the position to the start of the file\nrewind nd ( fp ) nfte ( fp ) Would assign to n because the file position has been set to the start of the file be rewind\nRemember the first byte in the file is numbered as second as and so on\nRemember that whenever a file is opened for reading or writing a rewind is done implicitly\n<eos>"
    },
    {
        "key": "file1_topic_71",
        "label": "error, fail, behave, typical, premature",
        "input": "<task:clean> <sos>\nError handling during IO operation It is possible that an error may occur during IO operations on a file\nTypical error situation include\nIf we fail to check such read and write errors a program may behave abnormally when an error occurs\nAn unchecked error may result in premature termination of the program or incorrect output\n<eos>"
    },
    {
        "key": "file1_topic_72",
        "label": "ferror, feof, message, error, end",
        "input": "<task:clean> <sos>\nWe have two statusinquiry library functions feof and ferror that can help up detect IO errors in the file\nThe feof function can be used to test for an end of file condition\nif ( feof ( fp ) ) printf ( End of data ) would display the message End of data on reaching the end of file condition\nThe ferror function report the status of the file indicated\nIt also takes a FILE pointer as its argument and returns a nonzero integer if an error has been detected up to that point during processing\nThe statement if ( ferror ( fp ) ) printf ( An error has occurred ) Would print the error message if the reading is no successful\n<eos>"
    },
    {
        "key": "file1_topic_73",
        "label": "goes, computed, nnnk, control, destination",
        "input": "<task:clean> <sos>\nThe general form is GO TO n where n is the statement number to which the control must be transferred\nThe blank between GO and TO is optional\nGO TO In the GO TO statement the number referenced can not be a variable example GO TO I is not valid\nComputed GO TO statement The computed GO TO statement cause the transfer of control depending upon value of an integer variable\nthe destination ( where to go ) is decided by the value in the integer variable\nthe general form is GO TO ( nnnk ) i where i is the integer variable nnnk are statement numbers\nIf the value is negative the control goes to statement number n if it is zero it goes to n and if it is positive it goes to n\n<eos>"
    },
    {
        "key": "file1_topic_74",
        "label": "implied, read, print, continue, loop",
        "input": "<task:clean> <sos>\nCHARACTER statement Practice Write a program to find the range from the list of element using array in FORTRAN\nC RANGE OF MATRIX INTEGER A ( ) LS PRINT ENTER THE ELEMENT TO ARRAY DO I READ A ( I ) CONTINUE LA ( ) SA ( ) DO I IF ( LLTA ( I ) ) THEN LA ( I ) ENDIF IF ( SGTA ( I ) ) THEN SA ( I ) ENDIF CONTINUE PRINT LAGREST ELEMENTL PRINT SMALEST ELEMENTS PRINT RANGELS STOP END IMPLIED DO loop Suppose we want to read all the entries of a one dimensional array A with array length\nINTEGER A ( ) DO I READ A ( I ) CONTINUE FORTRAN also has the facility of reading or writing the entire array with one statement\nREAD ( ) ( A ( I ) I ) Similarly the following is the implied DO loop to print the elements of the array\nC ASCENDING ORDER OF MATRIX INTEGER A ( ) TEMP PRINT ENTER THE ELEMENT TO ARRAY READ ( ) ( A ( I ) I ) DO I DO JI IF ( A ( I ) GTA ( J ) ) THEN TEMPA ( I ) A ( I ) A ( J ) A ( J ) TEMP ENDIF CONTINUE PRINT THE ELEMENT TO ARRAY WRITE ( ) ( A ( I ) I ) STOP END Implied DO loop for multidimensional array The implied DO loop can also be used for multidimensional arrays\nINTEGER A ( ) DO I DO J READ A ( IJ ) CONTINUE But we can use the implied DO loop and write this as a single statements as follows\nREAD ( ) ( ( A ( IJ ) J ) I ) Notice that the outer loop has I as running variable and the inner loop has J\n<eos>"
    },
    {
        "key": "file2_topic_75",
        "label": "problem, solving, steps, solve, analyse",
        "input": "<task:clean> <sos>\nProblem is defined as the difference between an existing situation and a desired situation that is in accordance with calculation a problem is numerical situation and has complex form\nIf a problem is solved by computing using machine called computer then such process is called Problem Solving using Computer\nProblem Analysis If you have studied a problem statement then you must analyse the problem and determine how to solve it\nFirst you should know the type of problem that is nature of problem\nAt first you try to solve manually\nIf it is solvable manually by using your idea and knowledge then you can use such idea and principle in programming and solve the problem by using computer\nSo you must have well knowledge about a problem\nIn order to get exact solution you must analyse the problem\nTo analyse means you should try to know the steps that lead you to have an exact solution\nSuppose you are asked by your father to solve an arithmetic problem and you are not familiar with the steps involved in solving that problem\nIn such a situation you will not be able to solve the problem\nSuppose you know the steps to be followed for solving the given problem but while solving the problem you forget to apply some steps or you apply the calculation steps in the wrong sequences\nWhat is a Problem\nWhy do we need documentation and testing for problem solving\nGenerally a difficult problem is divided into sub problems and then solved\nThe solution of the problem is built on the results from the smaller versions\nThey are Problem could be written or defined in terms of its previous result\n<eos>"
    },
    {
        "key": "file2_topic_76",
        "label": "errors, wrong, computer, programmers, occur",
        "input": "<task:clean> <sos>\nIn programming point of view the problem must be computing\nObviously you will get a wrong answer\nSimilarly while writing a computer program if the programmer leaves out some of the instructions for the computer or writes the instructions in the wrong sequences then the computer will calculate a wrong answer\nGenerally programmers commit three types of errorsThey are\nRuntime errors Syntax errors are those errors which are arised from violating the rules of programming languageOn encountering these errors a computer displays error messageIt is easy to debugLogic errors are those which arised when programmers proceed the logic process in wrong way or miss the some statementsIt is difficult to debug such errors because the computer does not display themRuntime errors are those which occur when programmers attempt to run ambiguous instructionsThey occur due to infinte loop statementdevice errorssofware errors etcThe computer will print the error message Some of runtime errors are Divide by zero Null pointer assignment Data over flow Testing is the process of reviewing and executing a program with the intent of detecting errors\nThe purpose of this material is to introduce certain basic concept and to provide some necessary definitions\n<eos>"
    },
    {
        "key": "file2_topic_77",
        "label": "instruction, computer, programming, sequence, language",
        "input": "<task:clean> <sos>\nThe same principle applies to writing computer program also\nA programmer can not write the instruction to be followed by a computer unless the programmer knows how to solve the problem manually\nThus to produce an effective computer program it is necessary that the programmers write each and every instruction in the proper sequence\nHowever the instruction sequence ( logic ) of a computer program can be very complex\nHence in order to ensure that the program instructions are appropriate for the problem and are in correct sequence program must be planned before they are written\nCoding In order to make a program in any programming language what we have written is known as code\nThe act of writing code in a computer language is known as coding\nIn other words code is a set of instruction that a computer can understand\nCompilation Execution The process by which source codes of a computer ( programming ) language are translated into machine codes is known as compilation\nA programming language is designed to help process certain kinds of data consisting of numbers characters and strings and to provide useful output known as information\nThe task of programming of data is accomplished by executing a sequence of precise instruction called a program\nNormally however this is not done as it is considered a poor programming practice\n<eos>"
    },
    {
        "key": "file2_topic_78",
        "label": "algorithm, characteristics, posses, prepare, formally",
        "input": "<task:clean> <sos>\nAlgorithm Development Flowcharting The term algorithm may be formally defined as a sequence of instructions designed in such a way that if the instructions are executed in the specified sequence the desired result will be obtained\nAn algorithm must posses the following characteristics\nNormally an algorithm is first represented in the form of a flowchart and the flowchart is then expressed in some programming language to prepare a computer program\nDefine algorithm and flowchart\nDifferentiate between the flow chart and algorithm with the example\n<eos>"
    },
    {
        "key": "file2_topic_79",
        "label": "instruction, infinitely, noted, unambiguous, strictly",
        "input": "<task:clean> <sos>\nEach and every instruction should be precise and unambiguous\nEach instruction should be such that it can be performed in a finite time\nOne or more instruction should not be repeated infinitely\nIt may also be noted that in order to solve a given problem each and every instruction must be strictly carried out in a particular sequence\n<eos>"
    },
    {
        "key": "file2_topic_80",
        "label": "students, examination, roll, obtained, subjects",
        "input": "<task:clean> <sos>\nProblem There are students in a class who appeared in their final examination\nTheir mark sheets have been given to you\nProblem A student appears in an examination that consists of total subjects each subject having maximum marks of\nThe roll number of the students his name and the marks obtained by him in various subjects is supplied as input data\nDraw a flowchart for the algorithm to calculate the percentage marks obtained by the student in this examination and then to print it along with his roll number and name\nDisplay the name and roll no of those students mark is greater than\nWrite a program to read several different names roll address percentage and display name who has score the rd highest\nFeed the marks obtained by three students in each subjects and calculate the total of each student\nWrite a program to enter name roll and mark of students and store them in the file\n( PU ) Write a program to create a data files containing record roll number and students name and total marks\n<eos>"
    },
    {
        "key": "file2_topic_81",
        "label": "step, total, mark, division, sheet",
        "input": "<task:clean> <sos>\nWrite an algorithm to calculate and print the total number of students who passed in first division\nAlgorithm Step Initialize Total First Division and Total Mark sheet checked to zero ie\ntotal_first_div total_marksheet_chkd Step Take the mark sheet of the next student\nStep Check the division column of the mark sheet to see if it is I if no go to step\nStep Add to Total First Division ie\ntotal_first_div Step Add to Total Mark sheets checked ie\ntotal_marksheet_chkd Step Is Total Mark sheets checked if no go to step Step Print Total First Division\n<eos>"
    },
    {
        "key": "file2_topic_82",
        "label": "flowchart, logic, pictorial, drawing, flow",
        "input": "<task:clean> <sos>\nFlowchart A flowchart is a pictorial representation of an algorithm that uses boxes of different shapes to denote different types of instructions\nThe main advantage of this two steps approach in program writing is that while drawing a flowchart one is not concerned with the details of the elements of programming language\nSince a flowchart shows the flow of operations in pictorial form any error in the logic of the procedure can be detected more easily than in the case of a program\nOnce the flowchart is ready the programmer can forget about the logic and can concentrate only on coding the operations in each box of the flowchart in terms of the statements of the programming language\nA flowchart therefore is a picture of the logic to be included in the computer program\nExperienced programmers sometimes write programs without drawing the flowchart\nHowever for a beginner it is recommended that a flowchart be drawn first in order to reduce the number of errors and omissions in the program\nIt is a good practice to have a flowchart along with a computer program because a flowchart is very helpful during the testing of the program as well as while incorporating further modifications in the program\nThe communication of program logic through flowcharts is made easier through the use of symbols that have standardized meanings\nThe normal flow of flowchart is from top to bottom and left to right\nConnector If a flowchart becomes very long the flowlines start crisscross at many places that causes confusion and reduces understandability of the flowchart\nWhat is flow charting describe its importance\nWhat is a flowchart\n<eos>"
    },
    {
        "key": "file2_topic_83",
        "label": "flowlines, symbols, arrowheads, flowchart, good",
        "input": "<task:clean> <sos>\nFlowchart Symbols A flowchart uses boxes of different shapes to denote different types of instructions\nOnly a few symbols are needed to indicate the necessary operations in a flowchart\nFlowlines Flowlines with arrowheads are used to indicate the flow of operations that is the exact sequence in which the instructions are to be executed\nArrowheads are required only when the normal top to bottom flow is not to be followed\nHowever as a good practice and in order to avoid ambiguity flowlines are usually drawn with an arrowhead at the point of entry to a symbol\nGood practice also dictates that flowlines should not cross each other and that such intersections should be avoided whenever possible\nWhat are the various symbols used to a flowchart\nList the various commonly used flowchart symbols\n<eos>"
    },
    {
        "key": "file2_topic_84",
        "label": "true, operands, logic, result, false",
        "input": "<task:clean> <sos>\nFor example a diamond always means a decision\nit causes an expression that is originally true to become false and viceversa\nThe result of a logic and operation will be true only if both operands are true where as the result of a logic or operation will be true if either operand is true or if both operands are true\nIn other word the result of a logic or operation will be false only if both operands are false\n<eos>"
    },
    {
        "key": "file2_topic_85",
        "label": "inputoutput, input, terminal, device, output",
        "input": "<task:clean> <sos>\nThese symbols are listed below Terminal InputOutput Processing Terminal The terminal symbol as the name implies is used to indicate the beginning ( START ) ending ( STOP ) and pauses ( HALT ) in the program logic flow\nInputOutput The inputoutput symbol is used to denote any function of an inputoutput device in the program\nIf there is a program instruction to input data from a disk tape cardreader terminal or any other type of input device that step will be indicated in the flowchart with an inputoutput symbol\nSimilarly all output instructions whether it is output on a printer magnetic tape magnetic disk terminal screen or any output device are indicated in the flowchart with an inputoutput symbol\nThe data that is given to a program is known as input data\nSimilarly the data that is provided by a program is known as output data\nGenerally input data is given to a program from a keyboard ( a standard input device ) or a file\nThe program then proceeds the input data and the result is displayed on the screen ( monitor a standard output device ) or a file\nReading input data from keyboard and displaying the output data on screen such input output system is considered as conio input out\nInput Output Fig Input Output To perform inputoutput operation in console mode C has a number of input and output functions\nWhen a program needs data it takes the data through the input functions and sends the results to output devices through the output functions\nThus the inputoutput functions are the link between the user and the terminal\nAs keyboard is a standard input device the input functions used to read data from keyboard are called standard input functions\nSo its work is merely to hold the output screen until a key is pressed\nDescribe any two file handling inputoutput function\n<eos>"
    },
    {
        "key": "file2_topic_86",
        "label": "executed, order, consecutively, enable, computations",
        "input": "<task:clean> <sos>\nWhen more than one arithmetic and data movement instructions are to be executed consecutively they are normally placed in the same processing box and they are assumed to be executed in the order of their appearance\nIn the absence of control statements the instruction or statements are executed in the same order in which they appear in the program\nSo control statements enable use to specify the order in which various instruction in the program are to be executed\nThis process is used for repetitive computations in which each action is stated in term of previous result\n) Increasing the execution speed as they refer address\n<eos>"
    },
    {
        "key": "file2_topic_87",
        "label": "testing, based, inspection, manual, codes",
        "input": "<task:clean> <sos>\nTesting can be done manually and computer based testing\nManual Testing is an effecting errordetection process and is done before the computer based testing begins\nManual testing includes code inspection by the programmer code inspection by a test group and a review by a peer group\nComputer based testing is done by computer with the help of compiler ( a program that changes source codes into machine codes word by word )\n<eos>"
    },
    {
        "key": "file2_topic_88",
        "label": "documentation, internal, define, explanatory, comments",
        "input": "<task:clean> <sos>\nProgram Documentation Program Documentation refers to the details that describe a programWhile writng programs it is good programming practice to make a brief explanatory note on the programor program segmentThis explanatory note is called commentIt explains how the program works and interact with itThus it helps other programmers to understand the programThere are two types of documentation Internal documentation Some details may be builtin as an integral part of the program\nThese are known as internal documentation\nTwo important aspects of internal documentation are selection of meaningful variable names and the use of comments\nFor example Area Breadth Length is more meaningful than A B L And comments are used to describe actions parts and identification in a program\nExternal documentation is an executable statement in a programIt may be message to the user to respond to the program requirementThis is accomplished using output statements It makes a program more attractive and interactiveSome examples are print Input the number one by one print Do you want to continue Some Important Questions\nThis section consists two parts declaration part and executable part\nFor example define TAXRATE define PI define TRUE define FALSE define FRIEND Susan area PI radius radius is equivalent to Some Important Questions\nIt can also be defined as a section of a program performing a specific task\nIt may be auto static extern and register It is optional\n<eos>"
    },
    {
        "key": "file2_topic_89",
        "label": "unix, operating, developed, language, level",
        "input": "<task:clean> <sos>\nC contains additional features that allow it to be used at a lower level thus bridging the gap between machine language and the more conventional high level language\nThis flexibility allows C to be used for system programming ( eg\nThe new language was named C Since it was developed along with the UNIX operating system it is strongly associated with UNIX\nThis operating system was developed at Bell Laboratories and was coded almost entirely in C C was used mainly in academic environments for many years but eventually with the release of C compiler for commercial use and the increasing popularity of UNIX it began to gain widespread support among compiler professionals\nToday C is running under a number of operating systems including MsDOS\nIn fact many of the C compilers available in the market are written in C Programs written in C are efficient and fast\nC is highly portable\nThis means that C programs written for one computer can be seen on another with little or no modification\nPortability is important if we plan to use a new computer with a different operating system\nAnother important feature of C is its ability to extend itself\nThese computers often have small amounts of storage within the CPU itself where data can be stored and accessed quickly\n<eos>"
    },
    {
        "key": "file2_topic_90",
        "label": "language, suited, programming, high, builtin",
        "input": "<task:clean> <sos>\nIt also resembles other high level structure programming language such as Pascal and Fortran\nB language was modified by Dennis Ritchie and was implemented at Bell Laboratories in\nIt is a robust language whose rich set of builtin functions and operators can be used of builtin functions and operators can be used to write any complex program\nThe C compiler combines the capabilities of an assemble language with the features of a highlevel language and therefore it well suited for writing both system software and business packages\nIt is many times faster than BASIC ( Beginners All Purpose Symbolic Instruction Code a high level programming language )\nC Language is well suited for structure programming thus requiring the user to think of a problem in terms of function modules or blocks\n<eos>"
    },
    {
        "key": "file2_topic_91",
        "label": "collection, functions, modules, divided, task",
        "input": "<task:clean> <sos>\nA proper collection of these modules would make a complete program\nA C program is basically a collection of functions that are supported by the C library\nWith the availability of a large number of functions the programming task becomes simple\nBasic Structure of C programs Every C program consists one or more modules called function\nEvery C program can be though of as a collection of these functions\nEach program has one or more functions\nA program can be divided into functions each of which performs some specific task\nSo the use of C functions modularizes and divides the work of a program\nTypes of Functions C program has two types of functions\nA complex C program can be divided into a number of user defined functions\n<eos>"
    },
    {
        "key": "file2_topic_92",
        "label": "global, variables, local, outside, life",
        "input": "<task:clean> <sos>\nSuch variables are called global variables and are declared in global declaration section that is outside of all the function\nThe local variables are created when the function is called and destroyed automatically when the function is exited\nLife time The period of time during which memory is associated with a variable is called the Program to illustrate local variable long int fact ( int n ) int i long int f for ( i in i ) f i return ( f ) main ( ) int num clrscr ( ) printf ( Enter a number ) scamf ( d num ) printf ( The factorial of d is ld num fact ( num ) ) Output Enter a number The factorial of is Global Variables ( External ) The variables that are defined outside any function are called global variables\nAll functions in the program can access and modify global variables\nIT is useful to declare a variable global if it is to be used by many functions in the program\nThe life time is as long as the programs execution does not come to an end\nWhat are local and global variables\n<eos>"
    },
    {
        "key": "file2_topic_93",
        "label": "semicolon, executable, declaration, variables, declares",
        "input": "<task:clean> <sos>\nThe declaration part declares all the variables used in the executable part\nAll the statements in the declaration and executable parts ends with a semicolon\nThe type declaration will apply throughout the program\nDeclarations A declaration associates a group of variables with a specific data type\nAll variables must be declared before they can appear in executable statements\nA declaration consists of a data type followed by one or more variable names ending with a semicolon\nThe userdefined data type identifier can later be used to declare variables\nIt doesnt require semicolon\n<eos>"
    },
    {
        "key": "file2_topic_94",
        "label": "braces, unit, closing, opening, surrounded",
        "input": "<task:clean> <sos>\nThese two parts must appear between the opening and the closing braces\nThe program execution begins at the opening braces and ends at the closing brace\nThis is a logical unit composed of a number of statements grouped into a single unit\nIt is a block of statements surrounded by braces\n<eos>"
    },
    {
        "key": "file2_topic_95",
        "label": "exit, jump, brace, demonstrate, inclusion",
        "input": "<task:clean> <sos>\nThe closing brace of the main ( ) function section is the logical end of the program\nExit ( ) function We have already known that we can jump out of a loop using either the break statement or goto statement\nIn a similar way we can jump out of a program by using the library function exit ( )\nThe general syntax is if ( condition ) exit ( ) The exit ( ) function takes an integer value as its argument\nThe use of exit ( ) function requires the inclusion of the header file\nProgram to demonstrate exit ( ) include include main ( ) int choice clrscr ( ) while ( ) printf (\n<eos>"
    },
    {
        "key": "file2_topic_96",
        "label": "opening, establishing, labc, file, connection",
        "input": "<task:clean> <sos>\nThe file name should end with the characters c like program c labc etc\nThis provides the operating system the name of the file and the mode in which the file is to be opened\nThe process of establishing a connection between the program and file is called opening the file\nIn other word it specifies the purpose of opening a file\nExplain in brief the steps involved in opening a file\n<eos>"
    },
    {
        "key": "file2_topic_97",
        "label": "constant, set, character, equivalent, characters",
        "input": "<task:clean> <sos>\nCharacter Set C uses the uppercase letters A to Z the lowercase letters a to z the digits to and certain special characters as building blocks to form basic program elements ( eg\nSeveral character constants are shown below A X Character constants have integer values that are determined by the computers particular character set\nThus the value of a character constant may vary from one computer to another\nThe constants themselves however are independent of the character set\nThis feature eliminates the dependence of a C program on a particular character set\nAmerican Standard Code for Information Interchange ) character set in which each individual character is numerically encoded with its own unique bit combination ( hence a total of difference characters )\nSeveral character constant and their corresponding values as defined by ASCII Constant Value A X These values will be the same for all computer that utilize the ASCII character set\nString Constants A string consists of any number of consecutive characters ( including none ) enclosed in ( double ) quotation marks\nA character constant ( eg\nA ) and the corresponding singlecharacter string constant ( A ) are not equivalent\nA character constant has an equivalent integer value whereas a single character string constant does not have an equivalent integer value and in fact consists of two characters the specified character followed by the null character ( o )\nThe null character constant is not equivalent to the character constant\nThe characters may represent numeric constant a character constant or a string constant\nWhat do you mean by Character set in C\nA symbolic constant NULL is defined in stdioh which denotes the value zero\n<eos>"
    },
    {
        "key": "file2_topic_98",
        "label": "whitespace, groups, group, characters, multiple",
        "input": "<task:clean> <sos>\n( Blank space ) ( Horizontal tab ) ( White Space ) Most versions of the language also allow certain other characters such as and to be included with strings comments\nMust not contain white space\nThe control string consists of individual groups of characters with one character group for each input data item\nWithin the control string multiple character groups can be contiguous or they can be separated by whitespace ( ie\nblankspace ) tabs or newline characters\nIf whitespace characters are used to separate multiple character groups in the control string then all consecutive whitespace characters in the input data will be read but ignored\nThe use of blank spaces as character group separators is very common\nThe consecutive nonwhitespace characters that define a field\nMultiple character group can be contiguous or they can be separated by other characters including whitespace character\nThe use of blank spaces are character group separators is particularly common\n<eos>"
    },
    {
        "key": "file2_topic_99",
        "label": "tokens, linefeed, token, punctuation, passage",
        "input": "<task:clean> <sos>\nIdentifiers Keywords C Tokens In a passage of text individual words and punctuation marks are called tokens\nSimilarly in a C program the smallest individual units are also known as C tokens\nC has six types of tokens\nFor example a linefeed ( LF ) which is referred to as a newline in C can be represented as n\nWhat are the token of C language\n<eos>"
    },
    {
        "key": "file2_topic_100_0",
        "label": "loop, continue, rem, body, sum",
        "input": "<task:clean> <sos>\nint float for while\nStop Counter Initialization Test Condition False True Body of Loop Update expression Out of Loop For example Calculate the factorial of a number factorialc include main ( ) int num i long fact clrscr ( ) printf ( n Enter a number whose factorial is to be calculated ) scanf ( d num ) for ( i inum i ) fact i fact facti printf ( n The factorial is d fact ) getch ( ) Output Enter a number whose factorial is to be calculated The factorial is While Loop The while statement can be written as while ( condition ) while ( condition ) statement statement body of the loop statement First the condition is evaluated if it is true then the statements in the body of loop are executed\nfig Flowchart of while loop Program to print the sum of digits of any num while condition Body of Loop Next statement out of loop include main ( ) int n sum rem clrscr ( ) printf ( Enter the number ) scanf ( d n ) while ( n ) rem n taking last digit of number sum rem sum sum rem n n n skipping last digit end of while printf ( Sum of digits d n sum ) getch ( ) Output Enter the number Sum of digits dowhile loop The dowhile statement is also used for looping\nprogram to print the number from to using do while include main ( ) int i clrscr ( ) do printf ( dt i ) i while ( i ) printf ( n ) getch ( ) Output Body of Loop False Condition Next statement out of loop True Differences between while loop and do while loop Nesting of loops When a loop is written inside the body of another loop then it is known as nesting of loops\n<eos>"
    },
    {
        "key": "file2_topic_100_1",
        "label": "loop, continue, rem, body, sum",
        "input": "<task:clean> <sos>\nThe general syntax continue fig flowchart of continue control statemen Program to demonstrate continue statement include main ( ) int i num clrscr ( ) printf ( n Enter a number ) scanf ( d num ) printf ( n The even numbers from to d are n num ) for ( i inum i ) if ( i ) continue printf ( td i ) end of for loop getch ( ) end of main ( ) Output Enter a number The even numbers from to are Loop statements before continue Next iteration of loop condition continue statements True false Loop statements after continue goto statement The goto statement is used to alter the normal sequence of program execution by unconditionally transferring control to some other part of the program\nt ) scanf ( d n ) printf ( n Enter d numbers n n ) for ( i inumj ) temp numi numi numj numj temp end of if end of inner loop end of outer loop printf ( n The numbers in ascending order n ) for ( i in i ) printf ( td numi ) getch ( ) end of main Output How many numbers are there\n<eos>"
    },
    {
        "key": "file2_topic_101",
        "label": "lowercase, letters, upper, uppercase, letter",
        "input": "<task:clean> <sos>\nIdentifiers consisted of letters and digits in any order except that first character must be a letter\nBoth upper and lower case letters are permitted though common usage favors the use of lowercase letters for most type of identifiers\nUpper and lowercase letters are not interchangeable ( ie\nan uppercase letter is not equivalent to the corresponding lowercase letters )\nMust consist of only letters digits or underscore\nOnly first characters are significant\nSince upper and lowercase characters are not equivalent it is possible to utilize an uppercase keyword as an identifier\nIt can then be followed by any combination of digits taken from the sets through and a through f ( either upper or lower case )\nThe letters may be written in either upper or lowercase\nSince the first lowercase letter ( in this case a ) would be interpreted as the first character beyond the string\nWrite a program to convert a lowercase character string into uppercase using array\nFor example fclose ( fp ) fclose ( fp )\n<eos>"
    },
    {
        "key": "file2_topic_102",
        "label": "underscore, middle, asterisk, period, dot",
        "input": "<task:clean> <sos>\nThe underscore ( _ ) can also be included and considered to be a letter\nAn underscore is often used in middle of an identifier\nAn identifier may also begin with an underscore\nTo do so the sign within the appropriate control group is followed by an asterisk ( )\nIt must start with a period ( )\nThe dot ( )\n<eos>"
    },
    {
        "key": "file2_topic_103",
        "label": "illegal, exponent, character, blank, xbff",
        "input": "<task:clean> <sos>\nFirst character must be an alphabet ( or Underscore )\nIllegal character ( blank space ) Illegal character ( ) the first digit can not be zero\nIllegal character ( ) Illegal character ( )\nxbff Illegal character ( )\nEither a decimal point or an exponent must be present\nIllegal character ( ) E The exponent must be an integer ( it can not contain a decimal point ) E Illegal character ( blank space ) in the exponent\nHowever will not be assigned partno because of asterisk which is interpreted as an assignment suppression character\n<eos>"
    },
    {
        "key": "file2_topic_104",
        "label": "bytes, byte, signed, unsigned, needs",
        "input": "<task:clean> <sos>\nData Types C language is rich in its data types\nC supports several different types of data each of which may be represented differently within the computer memory\nTypical memory requirements are also given Data Types Description Typical Memory Requirement char single character byte int integer quantity bytes float floatingpoint number bytes ( word ) double doubleprecision floating point number bytes ( word ) In order to provide some control over the range of numbers and storage space C has following classes signed unsigned short long\nTypes Size char or signed char byte unsigned char byte int bytes short int byte unsigned short int byte signed int bytes unsigned int bytes long int bytes signed long int bytes unsigned long int bytes float bytes double bytes long double bytes void is also a builtin data type used to specify the type of function\nBecause I needs bytes f needs bytes and c needs byte bytes is highest in these\n<eos>"
    },
    {
        "key": "file2_topic_105",
        "label": "union, structure, created, keyword, space",
        "input": "<task:clean> <sos>\nstructure union enum The basic data types are also known as built in data types\nis i Multiplication is i Union and its important Union is similar to structure data type but union store value of different types in a single location\nUnion will contain many different type of values but only one is stored at a time\nThe declaration of union is same as the structure\nOnly difference is in place of struct keyword the union keyword is used\nThe accessing of union member is also same like structure member\nFor example Union data int a float b The union variable are declared like structure variable\nFor example Union data d d If we write the statement da Then that means the field a is valid but we want to print the value of b after above assignment the value is wrong because a is valid only\nSpace Created for Union We know that union store one value at a time so the question is now much space is created for union\nFor example Union A int i float f char c union A a The space is created for a is byte\nDistinguish between Structure and union\n<eos>"
    },
    {
        "key": "file2_topic_106",
        "label": "octal, digits, taken, combination, digit",
        "input": "<task:clean> <sos>\nThus it consists of a sequence of digits\nA decimal integer constant can consists of any combination of digits taken from the set through\nAn octal integer constant can consist of any combination of digits taken from the set through\nHowever the first digit must be in order to identify the constant as an octal number\nThe general form represents an octal digit ( through )\n<eos>"
    },
    {
        "key": "file2_topic_107",
        "label": "constants, illegal, integer, incorrectly, reason",
        "input": "<task:clean> <sos>\nSeveral valid decimal integer constants are shown below The following decimal integer constants are written incorrectly for reason stated Illegal character ( ) Illegal character ( )\nSeveral valid hexadecimal integer constants are shown below x X XFFF xabcd The following hexadecimal integer constants are written incorrectly for the reason stated X Illegal character ( )\nXDEFG Illegal character ( G ) Unsigned and Long Integer Constants Unsigned integer constants may exceed the magnitude of ordinary integer constants by approximately a factor of l though they may not be negative\nThe constants following the case keywords should be of integer or character type\n<eos>"
    },
    {
        "key": "file2_topic_108",
        "label": "null, termination, terminating, string, length",
        "input": "<task:clean> <sos>\nThus the string would be displayed as Line Line Line The compiler automatically places a null character ( ) at the end of every string constant as the last character within the string ( before the closing double quotation mark )\nNormally zero is used to indicate normal termination and non zero value to indicate termination due to some error or abnormal condition\nIn other words we can say that a string is a sequence of contiguous character in memory terminated by the null character\nThe terminating null character is important because it is the only way the string handling functions can know there the string ends\nThe second dimension tells the maximum length of each string\nIn above declaration we can store strings each can store maximum characters last th space is for null terminator in each string\nThe length of string is the number of characters present in it excluding the terminating null character\n<eos>"
    },
    {
        "key": "file2_topic_109",
        "label": "yielding, integervalued, represent, integer, returning",
        "input": "<task:clean> <sos>\nThus a b and c will each represent an integervalued quantity and d will represent a single character\nall integers all characters )\nFor example integer number ie\nIt can be value of any integer or character variable or a function call returning on integer or an arithmetic logical relational bitwise expression yielding integer value\n<eos>"
    },
    {
        "key": "file2_topic_110",
        "label": "assigned, follow, quantity, value, values",
        "input": "<task:clean> <sos>\nThe next four lines cause the following things to happen the integer quantity is assigned to a is assigned to b and the quantity represented by the sum ab ( e\n) is assigned to c The character a is assigned then assigned to d In the third line within this group the values of the variables a and b are accessed simply by writing the variables on the righthand side of the equal sign\nThe last four lines redefine the values assigned to the variables as the integer quantity is assigned to a replacing the earlier value then is assigned to b replacing the earlier value The difference between a and b ( ie\nA comma linked list of expression are evaluated left to right and the value of rightmost expression is value ( x y x y ) Here is assigned to x and is assigned to y and so expression xy is evaluated as ( ) ie\na b In this example x will be assigned the value of b\nint subject char sex M F float marks int element In example ( ) elements are five but we are assigning only three values\nint ) The value is assigned like follow a a a a a a int a In above example the two value in the first inner pair of braces are assigned to the array element in the first row the values in the second pair of braces are assigned to the array element in the second row and so on\nThe value assign like follow a a a a a a In above example the value zero is assigned to a and a because no value assigned to these\nIn above example value assign like follow a a a a a a int a int a would never work\n<eos>"
    },
    {
        "key": "file2_topic_111",
        "label": "size, array, dimension, tells, elements",
        "input": "<task:clean> <sos>\nEach array variable must be followed by a pair of square brackets containing a positive integer which specifies the size ( ie\nthe number of elements ) of the array\nThe size of this array will be equal to the value of argc\nsize of the array is the number of elements in the array\nFor example define size a size The size of the array must be specified ie\nFor example char str The first dimension ( size ) tells how many strings are in the array\n<eos>"
    },
    {
        "key": "file2_topic_112",
        "label": "california, text, meaningless, extra, filled",
        "input": "<task:clean> <sos>\nchar text California This declaration will cause text to be an element character array\nThe first elements will represent the characters within the word California and the th element will represent the null character ( ) which automatically added at the end of the string\nchar text California the character at the end of the string ( in this case the null character ) will be lost\nchar text California the extra array elements may be assigned zeros or they may be filled with meaningless characters\n<eos>"
    },
    {
        "key": "file2_topic_113",
        "label": "items, consider, type, data, integers",
        "input": "<task:clean> <sos>\nThe data items must all be of the same type ( eg\nFor example consider the following data\nIn such situation where we have multiple data items of same type to be stored we can use array\nThe individual data items can be characters integers floating point numbers etc\nHowever they must all be of the same type and the same storage class ( ie\nThe data item can be different type some can be int some can be float some can be char and so on\n<eos>"
    },
    {
        "key": "file2_topic_114",
        "label": "escape, sequence, newline, feed, ascii",
        "input": "<task:clean> <sos>\nAn escape sequence always begins with a backslash and is followed by one or more special characters\nSuch escape sequences always represent single characters even though they are written in terms of two or more characters\nThe commonly used escape sequences are listed below Character Escape Sequence ASCII Value bell ( alert ) a backspace b horizontal tab t vertical tab v newline ( line feed ) n form feed f carriage return r quotation mark ( ) apostrophe ( ) question mark ( )\nEscape Sequence represents the null character ( ASCII ) which is used to indicate the end of a string\nThe general form of a hexadecimal escape sequence is xhh where each h represents a hexadecimal digit ( through and a through f )\nWhat is Escape Sequence\nWrite any four escape sequence with meaning and symbols\nList out any threeescape sequence with their uses\nIf the character within the brackets is simply the circumflex followed by a newline character then string entered from the standard input device can contain any ASCII characters except the newline characters ( line feed )\nThe Enter Key will issue the newline character thus signifying the end of the string\n<eos>"
    },
    {
        "key": "file2_topic_115",
        "label": "typedef, type, units, existing, identifier",
        "input": "<task:clean> <sos>\nTypedef Statement C supports a feature known as type definition that allows users to define an identifier that would represent an existing data type\nIt takes the general form typedef type identifier where type refers to an existing data type and identifier refers to the new name given to the data type\ntypedef can not create a new type\nSome examples of type definition are typedef int units typedef float marks where units represent int and marks represents float\nThe main advantage of typedef is that we can create meaningful data type names for increasing the readability of the program\n<eos>"
    },
    {
        "key": "file2_topic_116",
        "label": "cprogram, kumar, ram, cprogramming",
        "input": "<task:clean> <sos>\nDescribe different data types are used in cprogram\nWrite down the various types of it in Cprogram\na include include void main ( ) char name clrscr ( ) printf ( Enter your name ) gets ( name ) printf ( your name is ) puts ( name ) getch ( ) output Enter your name Ram Kumar Your name is Ram Kumar Some Important Questions Write a general form of inputoutput statement of Cprogramming\nCPROGRAM X_FILE Y_FILE ) is passed on to the program through these arguments when main ( ) is called up by the system\nHow and when the they declared in Cprogram\n<eos>"
    },
    {
        "key": "file2_topic_117",
        "label": "division, integer, respectively, note, perform",
        "input": "<task:clean> <sos>\nDivision of one integer quantity by another is referred to as integer division\nSuppose that i j and k are integer variables whose values are and respectively\nIf the first number is greater than second perform multiplication otherwise division\nNote that x and y both are integer type\nWhere x and y both are integer type\n<eos>"
    },
    {
        "key": "file2_topic_118",
        "label": "floatingpoint, precision, variable, hand, dropped",
        "input": "<task:clean> <sos>\nthe decimal portion of the quotient will be dropped )\nOn the other hand if a division operation is carried out with two floatingpoint numbers or one floating point numbers and other integer the result will be a floating point\nSuppose that i is an integer variable whose value is f is a floatingpoint variable whose value is and c is a character variable that represents the character w\nSuppose that i is an integer variable x is a floatingpoint variable d is doubleprecision variable and c is character type variable\nThe first be read into a variable int the second into float and the third into char\nThe second will be assigned to a long decimal integer variable and the third will be assigned to a double precision variable\n Precision Optional The operation of precision field depends on the types of conversion\n<eos>"
    },
    {
        "key": "file2_topic_119",
        "label": "conditional, expressions, interpretation, make, logical",
        "input": "<task:clean> <sos>\nSeveral relational expressions involving these variables Expressions Interpretation Value i k true ( jk ) ( i ) false k\nnot Logical operators are used to compare evaluate logical and relational expressions\nSeveral complex logical expressions that make use of these variables are shown below Expression Interpretation Value ( i ) ( c w ) true ( i ) ( c ) true ( f ) false ( c\nis known as conditional operator\nSimple conditional operations can be carried out with conditional operator\nAn expression that make use of the conditional operator is called a conditional expression\nMake the comparison between them with conditional operator\n<eos>"
    },
    {
        "key": "file2_topic_120",
        "label": "expression, conditional, evaluating, negates, value",
        "input": "<task:clean> <sos>\nthat negates the value of a logical expression ie\np ) ( if ) true\nexpression expression When evaluating a conditional expression expression is evaluated first\nIf expression is true the value of expression is the value of conditional expression\nIf expression is false the value of expression is the value of conditional expression\n<eos>"
    },
    {
        "key": "file2_topic_121",
        "label": "operand, postfix, prefix, altered, utilized",
        "input": "<task:clean> <sos>\nIf the operator is written before the operand then it is called as prefix unary operator\nIf the operator is written after the operand then it is called as postfix unary operator\nWhen prefix is used the operand will be altered in value before it is utilized for its intended purpose within the program\nSimilarly when postfix is used the operand will be altered in value after it is utilized\nIt is a compile time operand\nThe operand may be a variable a constant or a data type qualifier\nThis operator can be read as the address of so sn means address of sn similarly price means address of price\n<eos>"
    },
    {
        "key": "file2_topic_122_0",
        "label": "printf, gender, output, str, format",
        "input": "<task:clean> <sos>\nSuppose the program includes the following three printf statements\nThe statements printf ( integer d n size of i ) printf ( float d n size of x ) printf ( double d n size of d ) printf ( character d n size of c ) might generate the following output integer float double character The above statement can also be written as printf ( integer dnsizeof ( int ) ) and so on\nchar text Kathmandu printf ( Number of characters dsizeof ( text ) ) will generate the following output Number of characters Conditional Operators The operator\nThe printf ( ) is a builtin function which is used to output data from the computer onto a standard output device ie\nThe printf ( ) statement provides certain features that can be used to control the alignment and spacing of printouts on the terminals\nThe general form of printf ( ) statement is printf ( control string arg arg\nSo the output generated will be fastener Example include main ( ) double x y printf ( fffffnn x y xy xy ) printf ( eeee x y xy xy ) The output are e e e Example read and write a line of text include main ( ) char line scanf ( n line ) printf ( s line ) Arun Kumar Arun Kumar Control string The general syntax of control string Flag Field width precision conversion character  Flags Optional T he flag affect the appearance of the output\nint n Format Output l w printf ( d n ) wl printf ( d n ) printf ( d n ) wl printf ( d n ) Format for floating point output The general form wpf wpe where w is the integer width including decimal point p is the precision f and e are conversion characters Example Format Output printf ( d ) printf ( ) printf ( x ) c printf ( f )\ne printf ( e ) printf ( g ) eg\nfloat x Format Output printf ( f x )\n<eos>"
    },
    {
        "key": "file2_topic_122_1",
        "label": "printf, gender, output, str, format",
        "input": "<task:clean> <sos>\nprintf ( f x )\nprintf ( f x ) _ printf ( f x ) printf ( f x ) printf ( e x ) e printf ( e x ) e printf ( e x ) e _ Output of Strings The general form of control string is wps where w specifies the field width for display and p instructs that only the first P characters of the string are to be displayed\nFormat Output M Y N E P A L printf ( s str ) M Y N E P A L printf ( s str ) M Y N printf ( s str ) M Y N E P printf ( s str ) printf ( s str ) M Y N E P A L Program to demonstrate unformatted function unformatc include include main ( ) clrscr ( ) char gender printf ( Enter gender M or F ) putchar ( gender ) getch ( ) Output Enter gender M or F M Our gender is M Note clrscr ( ) is a console fumction used to clear console ( display ) screen clrscr ( ) is pronoused clearscreengetch ( ) function is used to hold the console screen\n( PU ) Find the output the following program ( PU ) include Main ( ) int abc a b c printf ( dddnabc ) printf ( dddnabc ) Find the output of the following program ( PU ) include include void main ( ) int x float y char z C clrscr ( ) printf ( d f c nxyz ) getch ( ) Write short noteson Formatted inputoutput function\n( PUBack ) b Find the output of the following program\ninclude include main ( ) int a int P i clrscr ( ) p a printf ( dn ( pi ) ) getch ( ) The output of above program is Because the statement printf ( dn ( pi ) ) exzecute times from i to i\nSimilarly other elements are printed\nEOF ) printf ( sf in std\n<eos>"
    },
    {
        "key": "file2_topic_123",
        "label": "bitwise, shift, bits, operators, operator",
        "input": "<task:clean> <sos>\nBitwise Operators Bitwise Operators are used for manipulating data at bit level\nThese operators are used for testing the bits or shifting them right or left\nBitwise operators can be applied only to Operator Meaning Bitwise AND Bitwise OR Bitwise exclusive OR Right shift Bitwise ones complement operator Consider a and b\nTHe binary representation of a and b for bits a b c a b d a b n a e a b For Bitwise Shift Operator Operand Bitwise Shift operator number For eg\n<eos>"
    },
    {
        "key": "file2_topic_124",
        "label": "bytes, byte, address, allocated, memory",
        "input": "<task:clean> <sos>\nSize of Operator The size of operator is used with an operand to return the number of bytes it occupies\nRam The above line contains three types of data and must be read according to its format\nIt is assumed that the starting memory location is\nAs each integer element requires bytes subsequent element appears after gap of locations\nNormally each character is stored in one byte and successive characters of the string are stored in successive bytes\nThe memory in a computer is made up of bytes arranged in a sequential manner\nEach byte has an index number which is called address of that byte\nThe address of these bytes start from zero and the address of last byte is one less than the size of memory\nSuppose we have MB of RAM ( Random Access Memory ) then memory will consist of the address of these bytes will be from to\nThe address of first byte from the two allocated bytes is ka the address of variable age\nSuppose compiler has reserved bytes numbered and for the storage of variable age then the address of variable age will e\nMemory Address age Now this value will be stored in these bytes in form of binary representation\nThe number of bytes allocated will depend on the data type of variable\nFor example bytes would have been allocated for a float variable and the address of first byte would be called the address of variable\nGenerally bytes are used to store an address ( may vary in different computers ) so the compiler allocates bytes for a pointer variable\nbytes bytes ) is reserved and the address of the first byte of the memory allocated is assigned to the pointer x of type int ( ie\nx refers the first address of allocated memory )\n<eos>"
    },
    {
        "key": "file2_topic_125_0",
        "label": "check, img, odd, number, num",
        "input": "<task:clean> <sos>\nWrite a program to enter two numbers\nFor eg Program to check whether the number is ve or ve include main ( ) int num clrscr ( ) printf ( Enter a number to be tested ) scanf ( d num ) if ( num ) printf ( The number is negative ) printf ( value of num is dn num ) getch ( ) Output st run Enter a number to be tested The number is negative Value of num is nd run Enter a number to be tested Value of num is True Condition Statement False Next Statement ifelse statement The ifelse statement is an extension of the simple if statement\nProgram to check whether the number is even or odd include main ( ) int num remainder clrscr ( ) printf ( Enter a number ) Condition statement statement Next statement scanf ( d num ) remainder num modular division if ( remainder ) test for even printf ( Number is evenn ) else printf ( Number is oddn ) getch ( ) Output Enter a number Number is odd\nProgram to print whether the number is even or odd include main ( ) int n clrscr ( ) printf ( Enter the number ) scanf ( d n ) if ( n ) goto even else goto odd even printf ( Number is even ) goto end odd printf ( Number is odd ) end printf ( n ) getch ( ) Output Enter the number Number is even\n<eos>"
    },
    {
        "key": "file2_topic_125_1",
        "label": "check, img, odd, number, num",
        "input": "<task:clean> <sos>\nDisplay all recordsn ) printf ( Enter your choice ) scanf ( d choice ) switch ( choice ) case printf ( datase created nn ) break case printf ( Record inserted nn ) break case printf ( Record modified nn ) break case printf ( Record deleted nn ) break case printf ( Record displayed nn ) break case exit ( ) default printf ( Wrong choicen ) end of switch end of while getch ( ) end of main ( ) s Some Others Programs QWrite a program to check whether the number is prime or not\nprogam to check the num is prime or not primec include main ( ) int numic clrscr ( ) scanf ( dnum ) ic while ( iused for math function like sqrt ( ) and fabs ( ) main ( ) Float a b c xxdreal img printf ( n Enter the values of abc in axbx c t ) scanf ( fff a b c ) d b b a c if ( d ) d sqrt ( fabs ( d ) ) saqr used for square root fabs used for absolute value printf ( n The roots are imaginary ) real b ( a ) img d ( a ) printf ( x f i f f real img ) printf ( x f i f f real img ) else d sqrt ( d ) saqr used for square root fabs used for absolute value printf ( n The roots are imaginary ) real ( b d ) ( a ) img ( b d ) ( a ) printf ( x f t x f f real img ) getch ( ) Some Important Questions What is a control statement\nExplain with examples Write a program to check the given number is prime or not\nWrite a program to check number is palindrome or not\n<eos>"
    },
    {
        "key": "file2_topic_125_2",
        "label": "check, img, odd, number, num",
        "input": "<task:clean> <sos>\nA program to read a string and check for palindrome void main ( ) char st int len i pal clrscr ( ) printf ( Enter string of our choice ) gets ( st ) len strlen ( st ) for ( i i ( len ) i ) if ( sti\nstleni ) pal if ( pal ) printf ( n The input string is not palindrome ) else printf ( n the input string is palindrome ) getch ( ) Some Important Questions What is an array\n<eos>"
    },
    {
        "key": "file2_topic_126",
        "label": "table, conversion, standard, input, charater",
        "input": "<task:clean> <sos>\nThe standard input functions are scanf ( ) getchas ( ) getch ( ) gets ( ) etc\nSimilarly the output functions which are used to display the result on the screen are called standard output functions\nThe standard library stdioh provides functions for input and output\nTypes of IO The inputoutput functions are classified into two types i Formatted functions ii\nThe input function scanf ( ) and output Program function printf ( ) fall under this category\nThis is possible in C using the scanf function\nThe input data can be entered into the computer from a standard input device keyboard by means of the C library function scanf\nSeveral of the more frequently used conversion characters are listed below Table Conversion Charater Table Example inlcude main ( ) char item int partno float cost scanf ( s d f item partno cost ) The following data items could be entered from the standard input device when the program is executed\nExample include main ( ) char line scanf ( n line ) A variation of this feature which is often more useful is to precede the characters within the square brackets by a circumflex ( or caret )\nSeveral of the more frequently used conversion characters are listed below Table Conversion Charater Table Note l for long int h for signedunsigned short L for double\nFor example printf ( ) scanf ( ) sqrt ( ) getch ( ) etc\n<eos>"
    },
    {
        "key": "file2_topic_127",
        "label": "formatted, unformatted, format, output, refers",
        "input": "<task:clean> <sos>\nUnformatted functions Formatted Functions Formatted functions allow the input read from the keyboard or the output displayed on screen to be formatted according to our requirements\nWhile displaying a certain data on screen we can specify the number of digits after decimal point number of spaces before the data the position where the output is to be displayed etc using formatted functions\nFormatted Input Formatted input refers to an input data that has been arranged in a particular format\nFormatted Output Formatted output refers to the output of data that has been arranged in a particular format\nscreen This function can be used to output any combination of numerical values single character and strings\nargn ) where control string refers to a string that contains formatting information and arg arg argn are arguments that represent the individual output data item\nFormat for Integer Output wd where w is the integer number specifying the minimum field width of output data\nThe display is right justified For example char str MY NEPAL Unformatted Functions Unformatted functions do not allow the user to read or display data in desired format\n( PUBack ) include include void main ( ) char class country printf ( sclass ) printf ( cclass ) printf ( s rc class class ) getch ( ) Write the various input unformatted function and describe any two\nWrite the various output unformatted function and describe any two\n<eos>"
    },
    {
        "key": "file2_topic_128_0",
        "label": "cost, item, partno, scanf, arg",
        "input": "<task:clean> <sos>\nscanf ( ) stands for scan formatted\nThe general syntax of scanf function is scanf ( control string arg arg argn ) where control string refers to a string containing certain required formatting information so also known as format string and arg arg argn are arguments that represent the individual input data items\nExample include main ( ) int a b c scanf ( d d d a b c ) Suppose the input data items that are entered as Then the following assignment will result a b c If the data had been entered as Then the assignment would be a b c Now suppose that the data had been entered as Then the assignments would be a b c Finally suppose that the data had been entered as The resulting assignments would now be a b c Example include main ( ) int i float x char c If the data items are entered as T The output would now be The remaining two input characters ( and T ) will be ignored\nExample include main ( ) short ix iy long lx ly double dx dy scanf ( hd ld lf ix ly dx ) The control string in the first scanf function indicates that the first data item will be assigned to a short decimal integer variable\nThe control string in the second scanf function indicates that the first data item will have a maximum field width of characters and it will be assigned to short octal integer variable the second data item will have a maximum field width of characters and it will be assigned to a long hexadecimal integer variable and the third data item will have a maximum field width of characters and it will be assigned to double precision variable\nExample include main ( ) int partno float cost scanf ( s d f item partno cost ) If the corresponding data item are input fasterner fasterner is assigned to item and will be assigned to cost\n<eos>"
    },
    {
        "key": "file2_topic_128_1",
        "label": "cost, item, partno, scanf, arg",
        "input": "<task:clean> <sos>\nIn contrast to scanf ( ) function the arguments in a printf ( ) function do not represent memory addresses and therefore are not preceded by ampersands\nFor example include main ( ) char item int partno float cost printf ( sdf item partno cost ) Suppose fastener and have been assigned to name partno and cost\nIt offers an alternative function of scanf ( ) function for reading strings\nUnlike scanf ( ) function it doesnot skip whitespaces\n<eos>"
    },
    {
        "key": "file2_topic_129",
        "label": "eof, returns, success, error, significance",
        "input": "<task:clean> <sos>\nThe function returns the number of data items that have been entered successfully\nWhen the program receives this signal the file reading function returns EOF which is a constant defined in the file stdioh and its value is\nIt returns the integer written to file on success and EOF on error getw ( ) used to read integer value from a file\nIt returns the next integer from the ip file on success and EOF on error\nWhat is the significance of EOF\n<eos>"
    },
    {
        "key": "file2_topic_130",
        "label": "argu, command, line, argument, argc",
        "input": "<task:clean> <sos>\nActually the arguments represent pointers that indicate the addresses of the data items within the computers memory\nIn fact main can take two arguments called argi and argu and the information contained in the command line ( ie\nThe variable argc is an argument counter that the number of arguments on the command line\nThe argu is an argument vector and represents an array of character pointers that point to the command line arguments\nFor instance for the command line given above argc is three and argu is an array of three pointers to strings as shown below argu PROGRAM argu X_FILE argu Y _FILE In order to access the command line arguments we must declare the main function and its parameters as follows main ( argc argu ) int argc char argu WAP that will receive a filename and a line of text as command line arguments and write the text to the file\nThe command line F_ TEXT AAAAAA BBBBBB GGGGGG Each word in the command line is an argument to the main and therefore the total number of argument is\nThe argument vector argv points to the string TEXT and therefore the statement\nThe argument vector argv contains the entire command line in the memory and therefore the statement printf ( sn is argvi ) prints the argument from the memory\n<eos>"
    },
    {
        "key": "file2_topic_131",
        "label": "time, handle, heshe, cumbestsome, soon",
        "input": "<task:clean> <sos>\nThus the user may enter whatever he or she wishes and then presses the Enter Key\nIn both cases input accepted as soon as the character typed\nAt the same time it is cumbestsome and time consuming to handle large volume of data through keyboard\nIt takes a lot of time to enter the entire data\nIf the user makes a mistake while entering the data heshe has to start from the beginning again\nIf the same data is to be entered again at some later stage again we have to enter the same data\n<eos>"
    },
    {
        "key": "file2_topic_132",
        "label": "width, field, item, specified, characters",
        "input": "<task:clean> <sos>\nIt is possible to limit the number of such characters by specifying a maximum field width for that data item\nTo do so an unsigned integer indicating the field width is placed within the control spring between the The data item may contain fewer characters than the specified filed width\nHowever the number of characters in the actual data item can not exceed the specified field width\nAny characters that extend beyond the specified filed width will not be read\nSuch leftover characters may be incorrectly interpreted as the components of the next data item\nThe flags may be blank space or\nFlags Meanings Data item is left justified within the field\nThe blank spaces required to fill the TableFlags  Field Width Optional The field width is an integer specifying the minimum output field width\nIf the number of characters in the corresponding data item is less than the specified field width then the data item will be preceded by enough leading blanks to fill the specified field\nIf the number of characters in the data item exceeds the specified field width then additional space will be allocated to the data item so that the entire data item will be displayed\nIf the length of the variable is less than the specified field width then the variable is right justified with leading blanks\n<eos>"
    },
    {
        "key": "file2_topic_133",
        "label": "parameters, parameter, regular, needed, specifier",
        "input": "<task:clean> <sos>\nThe arguments can be written as constants single variable or array names or more complex expressions\nParameters ( as many as needed ) Each parameter consists of a data type specifier followed by an identifier like any regular variable declaration\nThe different parameters are separated by commas\nThese are known as actual parameter\n<eos>"
    },
    {
        "key": "file2_topic_134",
        "label": "control, mean, statements, different, statement",
        "input": "<task:clean> <sos>\nThere are two types of control statements\nWhat do you mean by control statements\nWhat is control statement\nDescribe different control statement\n<eos>"
    },
    {
        "key": "file2_topic_135",
        "label": "year, ifelse, large, leap, yearn",
        "input": "<task:clean> <sos>\nDecisions if ifelse nested ifelse switch Loops Loops are used when we want to execute a part of program or block of statement several times\nFollowing are decision making statements if statements ifelse statements else if statement Nested ifelse statement switch statement if statement The if statement is a powerful decision making statement and is used to control the flow of execution of statements\nFor example if ( condition ) if ( condition ) statementA else statement A Here we have ifelse inside both if block and else block else if ( condition ) statementB else statementB Program to find whether a year is leap or not include main ( ) int year clrscr ( ) printf ( Enter year ) if ( year ) if ( year ) printf ( Leap year n ) else printf ( Not leap yearn ) getch ( ) This can also be written in place of nested if else as if ( ( year year ) year ) printf ( d is a leap yearn year ) else printf ( d is not a leap yearn year ) Program to find largest number from three given number include main ( ) int a b c large clrscr ( ) printf ( Enter three numbers ) scanf ( ddd a b c ) if ( ab ) if ( ac ) large a else large c else if ( bc ) large b else large c printf ( Largest number is dn large ) getch ( ) Output Enter the numbers Largest num is else if statement This is a type of nesting in which there is an ifelse statement in every else part except the last else part\nStatements switch break continue goto Switch Statement This is a multidirectional conditional control statement\nThe statements under case can be any valid C statements like ifelse while for or even another switch statement\n<eos>"
    },
    {
        "key": "file2_topic_136_0",
        "label": "factorial, transfer, fib, temp, num",
        "input": "<task:clean> <sos>\nPrint Enter a number whose factorial is to be calculated\nInitilize fact to and counter i to For inum factfacti i End of For Print fact as factorial of the number num\nWAP to find the factorial of a number using recursive method long int factorial ( int n ) if ( n ) return ( ) else return ( nfactorial ( n ) ) main ( ) int num printf ( Enter a number ) scanf ( d num ) printf ( The factorial is ld factorial ( num ) ) Output Enter a number The factorial is The Towers of Hanoi The Towers of Hanoi is a well known childrens game played with three poles and a number of different size disk\n<eos>"
    },
    {
        "key": "file2_topic_136_1",
        "label": "factorial, transfer, fib, temp, num",
        "input": "<task:clean> <sos>\nThe Tower of Hanoi_solved using recursion include void transfer ( int n char from char to char temp ) function prototype main ( ) left Center Right int n printf ( Welcome to the Tower of Hanoi nn ) printf ( How many disk ) scanf ( d n ) printf ( n ) transfer ( n l R C ) void transfer ( int n char from char to char temp ) transfer n disks from one pole to another n number of disks from origin to destination temp temporary storage if ( n ) move n disk from origin to temporary transfer ( n from temp to ) move nth disk from origin to destination printf ( Move disk dfromctocn n from to ) move n disks from temporary to destination transfer ( n temp to from ) return Program Fibonacci number by recursion include include int fib ( int x ) if ( x x ) return else return ( fib ( x ) fib ( x ) ) main ( ) int i n no clrscr ( ) printf ( how many no in series ) for ( i in i ) no fib ( i ) printf ( d no ) getch ( ) WAP to add the natural numbers using recursive method long int add ( int n ) If ( n ) return else return ( n add ( n ) ) main ( ) int num clrscr ( ) printf ( Enter How many numbers ) scanf ( d num ) printf ( The sum of natural number is ld add ( num ) ) getch ( ) Output Enter How many numbers The sum of natural numbers is More about main ( ) We know that every C program should have one main ( ) function and that it marks the beginning of the program\nWrite a program to calculate factorial of n number by using recursive function where n is the number inputted by user\n<eos>"
    },
    {
        "key": "file2_topic_136_2",
        "label": "factorial, transfer, fib, temp, num",
        "input": "<task:clean> <sos>\nWrite a program in C to allow a user to enter an integer number interactively and display its factorial value\n<eos>"
    },
    {
        "key": "file2_topic_137",
        "label": "condition, statement, stat, true, executed",
        "input": "<task:clean> <sos>\nThis statement is used to test a condition and take one of two possible actions If the condition is true then a single statement or a block of statements is executed ( one part of the program ) other wise another single statement or a block of statements is executed ( other part of the program )\nsyntax if ( condition ) if ( condition ) statement statement statement n There can be a single statement or a block of statements after the if part\nFlowchart Fig Flowchart of if control statement Here if the condition is true ( nonzero ) then statement is executed and if it is false ( zero ) then the next statement which is immediately after the if control statement is executed\nThe syntax is if ( condition ) if ( condition ) statement else statement statement else statement Flowchart Fig Flowchart of ifelse control statement Here if the condition is true then statement is executed and if it is false then statement is executed\nAfter this the control transfers to the next statement which is immediately after the ifelse control statement\nif ( condition ) if ( condition ) statementA statementA else elseif ( condition ) if ( condition ) statementB statementB elseif ( condition ) else statementC if ( condition ) else statementC statement D else statement D The flowchart for else if statement is False True Condition False True Condition Stat A False True Condition Stat B Stat D Stat C Next Statement Program to find out the grade of a student when the marks of subjects are given\n<eos>"
    },
    {
        "key": "file2_topic_138",
        "label": "nested, falling, ladder, frequently, block",
        "input": "<task:clean> <sos>\nelse if statement Nested if else statement We can have another if else statement in the if block or the else block\nThis is called nested ifelse statement\nThis type of nesting is frequently used in programs and is also known as else if ladder\nThis is known as falling through cases\n<eos>"
    },
    {
        "key": "file2_topic_139",
        "label": "recordn, delete, insert, databasen, modify",
        "input": "<task:clean> <sos>\nCreate databasen ) printf (\nInsert new recordn ) printf (\nModify a recordn ) printf (\nDelete a recordn ) printf (\n<eos>"
    },
    {
        "key": "file2_topic_140",
        "label": "extern, tda, specification, storage, class",
        "input": "<task:clean> <sos>\nThe keyword auto may be used storage class specification while declaration of variable\nA variable declared inside a function without storage class specification auto is by default an automatic variable\nAn external variable must begin with the storage class specifier extern\nA variable declared outside a function without storage class specification extern is by default an external variable but defined after some function\nA program to illustrate the global variables int a void func ( ) a printf ( tda ) void main ( ) clrscr ( ) printf ( tda ) func ( ) printf ( tda ) Output Illustratration of extern variable main ( ) extern float marks func ( ) extern float marks float marks global space but defined after function The extern declaration does not allocate storage space variables\nThe extern declaration of marks inside the function informs the compiler that marks is a float type extern variable defined somewhere else in the program\n<eos>"
    },
    {
        "key": "file2_topic_141",
        "label": "static, increment, register, variable, initial",
        "input": "<task:clean> <sos>\nDefault initial value of such type of variable is an unpredictable value which is often called garbage value\nStorage class refers to the performance of a variable and its scope within the program\nInitial Value This is the initial value assigned by the language to a variable if no value is assigned to variable explicitly by the programmer\nThe default initial value for these variable is zero\nStatic variables Static variables are declared by writing keyword static in front of the declaration\nstatic type var_name A static variable is initialized once and the value of a static variable is retained between function call\nIf a static variable is not initialized then it is automatically initialized to O\nProgram with auto variable Program with static variable void increment ( ) void increment ( ) int i static int i printf ( dn i ) printf ( dn i ) i i main ( ) main ( ) clrscr ( ) increment ( ) increment ( ) increment ( ) increment ( ) increment ( ) increment ( ) increment ( ) increment ( ) getch ( ) getch ( ) Output Register variable Register variables are special case of automatic variables\nIf a variable is declared as register variable then it is stored in the CPU register\nThe scope of register variables is local to the block in which they are declared\nRules for initializations for register variables are the same as for automatic variables\nWhat is a static variable\nWrite a programin C that uses a static variable\nMemory Block We have studied that it is necessary to declare a variable before using it since compiler has to reserve space for it\nThe data type of the variable also has to be mentioned so that the compiler knows how much space need to be reserved\nFor example int age The compiler reserves consecutive bytes from memory for this variable and associates the name age with it\nLike all other variables it also has a name to be declared and occupies some space in memory\n<eos>"
    },
    {
        "key": "file2_topic_142",
        "label": "scope, life, block, defined, local",
        "input": "<task:clean> <sos>\nThe scope of it is local to the block in which the variable is defined\nAgain its life is till the control remains within the block in which the variable is defined\nScope Scope of a variable can be defined as the region over which the variable is visible or valid\nThe scope is global ie\nIts scope is local to the block in which the variable is defined\nAgain the life time is global ie\n<eos>"
    },
    {
        "key": "file2_topic_143",
        "label": "pole, disks, disk, poles, centre",
        "input": "<task:clean> <sos>\nEach disk has a hole in the centre allowing it be stacked around any of the poles\nInitially the disks are stacked on the leftmost pole in the order of decreasing size ie\nthe largest on the bottom and the smallest on the top\nThe object of the game is to transfer the disks from the leftmost pole to the rightmost pole without ever placing a larger disk on the top of a smaller disk\nOnly one disk may be moved at a time and each disk must always be placed around one of the poles\nThe general strategy is to consider one of the poles to be the origin and another to be the destination\nThe third pole will be used for immediate storage\nThus allowing the disks to be moved without placing a larger disk over a smaller one\nAssume there are n disks numbered from smallest to largest\nIf the disks are initially stacked on the left pole the problem of moving all n disks to the right pole can be stated in the following recursive manner\nMove the top n disks from the left pole to the centre pole\nMove the nth disk ( the largest disk ) to the right pole\nMove the n disks on the centre pole to the right pole\nIn order to program this game we first label the poles so that the left pole is represented as L the centre pole as C and the right pole as R We then construct a recursive function called transfer that will transfer n disks from one pole to another\nLet us refer to the individual poles with the char type variable from to and temp for the origin destination and the temporary storage respectively\nThus if we assign the character L to from R to and C to temp we will in effect be specifying the movement of n disks from the leftmost pole to righmost pole using the centre pole for immediate storage\n<eos>"
    },
    {
        "key": "file2_topic_144_0",
        "label": "source, content, file, welcome, college",
        "input": "<task:clean> <sos>\nThe for loop that follows immediately write the remaining arguments the file TEXT\nProgram also prints two output one from the file TEXT and the other from the system memory\ninclude void main ( ) FILE fp fp fopen ( Ctesttxt w ) if ( fp NULL ) else printf ( File has been successfully created ) fputs ( Welcome to Eastern College of Engineering fp ) fclose ( fp ) output goto C drive and see the text file testtxt in notepad where the content is Welcome to Program to open the file texttxt created above read its content display to the screen include Void main ( ) FILE fp char s fp fopen ( ctesttxt r ) if ( fp NULL ) printf ( In file can not be opened ) exit ( ) fgets ( s fp ) printf ( in the text from file is ts s ) fclose ( fp ) getch ( ) OUTPUT The text from file is Welcome to Eastern College of Engineering\nProgram that opens a file and copies all its content to another file\nTake source destination file from user include Void main ( ) FILE fsource fdest char ch source dest printf ( In Enter source file name t ) gets ( source ) printf ( Enter destination file name t ) gets ( dest ) fsource fopen ( source r ) if ( fsource NULL ) printf ( n source file can not be opened ) exit ( ) fdest fopen ( dest w ) if ( fdest NULL ) exit ( ) while ( ( ch fgetc ( source )\nThe syntax is long ftell ( FILE fp ) Some Programs Program to write some text welcome to my college to a data file in binary mode\n<eos>"
    },
    {
        "key": "file2_topic_144_1",
        "label": "source, content, file, welcome, college",
        "input": "<task:clean> <sos>\nRead its content and display it include Void main ( ) FILE fptr char c fptr fopen ( testtxt wb ) if ( fptr NULL ) printf ( n File can not be created ) fputs ( welcome to my college fptr ) printf ( The content from file n ) while ( cc fget c ffptr ) )\nEOF ) printf ( c C ) fclose ( fptr ) output The Content from file Welcome to my college\nRead and display the same from the file\nWrite a program that read a line of text and store file then print the content of file\nWrite a program to open a file in write mode take input form the keyboard and write it to the file\n<eos>"
    },
    {
        "key": "file2_topic_145",
        "label": "acceptable, elements, illustrated, perfectly, element",
        "input": "<task:clean> <sos>\nint a is a declaration of one dimensional array of type int\nIts elements can be illustrated as st element nd rd th th element a a a a a The elements of an integer array a are stored continuous memory locations\nint a b b a not acceptable if ( ab ) _ _ _ _ not acceptable we can assign integer values to these individual element directly a a a a a A loop can be used to input and output of the elements of array\na a a a a a int a In above example the values are less than the elements of array\nint a is perfectly acceptable\n<eos>"
    },
    {
        "key": "file2_topic_146",
        "label": "sizen, storage, follow, declaration, like",
        "input": "<task:clean> <sos>\ndeclaration of an array data_type array_namesize or if we want to add storage classes then that look like storage_class data_type array_namesize where storage_class refers to the storage class of the array\ndata_type is the data type of array\nInitialization of array The array is initialized like follow if we need time of declaration data_type array_namesize value value valuen For eg\nThe general format for declaring multidimensional array is data_type array_name size size sizen We can add storage class in above declaration if necessary like follow storage_class data_type array_namesize size sizen where storage_class part is optional\n<eos>"
    },
    {
        "key": "file2_topic_147",
        "label": "accessing, index, multidimensional, array, help",
        "input": "<task:clean> <sos>\narray_name is name of the array\nIt is user defined name for array\nThe name of array may be any valid identifier\nThe accessing function for array is array_nameindex or subscript For eg\nAccessing elements of multidimensional array We can access the multidimensional array with the help of following accessing function array_name index index\nAn array name can be named as an argument for the prototype declaration and in function header\n<eos>"
    },
    {
        "key": "file2_topic_148",
        "label": "stringh, manipulating, fprintf, fget, functions",
        "input": "<task:clean> <sos>\nIn C header file stringh provides special function for manipulating strings\nIn order to use these function we must include stringh file\nUnformatted IO functions a ) Character IO functions fget ( ) It is used to read a character from a file\nFormatted IO functions fprintf ( ) This function is used to write some integer float char or string to a file\n<eos>"
    },
    {
        "key": "file2_topic_149",
        "label": "dma, freeing, allocating, dynamic, run",
        "input": "<task:clean> <sos>\ninclude void main ( ) int a int i j clrsc ( ) for ( c i i ) for ( jo j j ) Printf ( dt ( ( ai ) j ) ) printf ( n ) getch ( ) output Dynamic Memory Allocation ( DMA ) The process of allocating and freeing memory at run time is ka Dynamic Memory Allocation\nIn such situation DMA will be useful\nThis is ka DMA\nDMA refers allocating and freeing memory at run time\n<eos>"
    },
    {
        "key": "file2_topic_150",
        "label": "realloc, allocated, previously, space, free",
        "input": "<task:clean> <sos>\nThis reserves the memory required by the program and returns this resource to the system once the use of reserved space utilized\nIn some cases it is not possible to know the size of the memory required well ahead and to keep a lot of memory reserved is not also good practice\nThere are library functions malloc ( ) calloc ( ) free ( ) and realloc ( ) for memory management\n) free ( ) The builtin function frees previously allocated space by calloc malloc or realloc function\nThis can be done using free ( ) function\nThs this function is used to release the space when it is not required\n) realloc ( ) This function is used to modify the size of previously allocated space\nSometimes the previously allocated memory is not sufficient we nned additional space and sometime the allocated memory is much larger than necessary\nIn both situations we can change the memory size already allocated with the help of function realloc ( )\nProgram to illustrate the use of realloc ( ) include include include void main ( ) charname clrscr ( ) name ( char ) malloc ( ) strcpy ( nameB\nThe space is created like II\n<eos>"
    },
    {
        "key": "file2_topic_151",
        "label": "calloc, ptr, malloc, allocates, size",
        "input": "<task:clean> <sos>\nTheses functions are defined within header file stdlibh and alloch ) malloc ( ) It allocates requested size of bytes and returns a pointer to the first byte of the allocated space\nIts syntax is as ptr ( data_typr malloc ( size_of_block ) where ptr is a pointer of type data_type\nThe malloc ( ) returns a pointer to an area of memory with size size_of_block\n) calloc ( ) The function calloc ( ) provides access to the C memory heap which is available for dynamic allocation of variable_size block of memory\nUnlike malloc ( ) the function calloc ( ) accepts two arguments no_of_blocks and size_of_block\nThis parameter no_of_blocks specifies the number of items to allocate and size_of_block specifies the size of each item\nThe function calloc ( ) allocates multiple blocks of storage each of the same size and then sets all bytes to zero\nOne important difference between malloc ( ) and calloc ( ) is that calloc ( ) initializes all bytes in the allocated block to zero\nIts syntax is ptr ( data_typecalloc ( no_of_blocksize_of_each_block ) For example x ( int ) calloc ( sizeof ( int ) ) or x ( int ) calloc ( ) The above statement allocates contiguous space for blocks each of size bytes ie\nIts syntax is Free ( ptr ) Where ptr is a pointer to a memory block which has already been created by malloc ( ) calloc ( ) or realloc ( ) function\nIts syntax is as If the original allocation is done by the statement ptrmalloc ( size ) then reallocationof space may be done by the statement ptrrealloc ( ptrnewsize ) This function allocates a new memory space of new size to the pointer variable ptr and returns a pointer to the first byte of new memory block and on failure the function return NULL\n<eos>"
    },
    {
        "key": "file2_topic_152_0",
        "label": "var, semester, branch, structure, struct",
        "input": "<task:clean> <sos>\nDefining a structure arrays of structures structures within structures The general syntax for declaration of a structure is storage_class struct name data_type member data_type member data_typen membern where the storage_class is optional\nFor example ) struct student char name int roll_no char branch int semester ) static struct data int day char month_name int year Creating structure variable In above section we have studied about how we declare structure but have not created the structure variable\nMethod of creating structure variable I creating structure variable at the time of declaration Example struct student char name int roll_no char branch int semester var var var In this example three structure variables name var var var are created\nstruct student structure declaration char name int roll_no char branch int semester var name roll_no branch semester var name roll_no branch semester name var roll_no branch semester struct student var var var Accessing member of structure The accessing concept of member is structure_variable_name\nmark is equivalent to ( varmarks ) Implies that the dot operator acts first and thenunary operatorFor example struct bio char name char address long phno struct bio b b for accessing bphno Initialization of structure A structure is initialized like other data type in C The values to be initialized must appear in order sa in the definition of structure within braces and separated by commas\nIts syntax is struct structure_name structure_variable value value value _ _ _ _ valuen ( ) struct particular int rn int age char sex We can initialize the structure at the time of variable creation like struct_particular per m By this is assigned to m of per is assigned to age of per and m is assigned to sex of per structure\n( ) struct bio int age int rn char sex int phno If we write the following statement strwt bio b m In above example C compiler assigns following value to each member age sex m rn phno So C compiler will automatically initialized zero to those members who are not initialized\n<eos>"
    },
    {
        "key": "file2_topic_152_1",
        "label": "var, semester, branch, structure, struct",
        "input": "<task:clean> <sos>\nFor example Create a structure named date that has day month and year as its members\n<eos>"
    },
    {
        "key": "file2_topic_153",
        "label": "structure, pointer, members, member, accessed",
        "input": "<task:clean> <sos>\nNote that the space in the memory for a structure is created only when the structure variable are defined\nC doesnot allow the initialization of individual structure member within its definition\nTo store address of a structure type variable we can define a structure type pointer variable as normal way\nThis declaration for a pointer to structure does not allocate any memory for a structure but allocates only for a pointer\nTo use structures members through pointer p memory must be allocated for a structure by using function malloc ( ) or by adding declaration and assignment as given below p b Here the base address of b can assign to p pointer\nAn individual structure member can be accessed in terms of its corresponding pointer variable by writing ptr_variable member where is called arrow operator and there must be pointer to the structure on the left side of this operator\nC compiler first calculates the size of all members and then reserves the space which is highest among them\nHow structure members are accessed using pointer\n<eos>"
    },
    {
        "key": "file2_topic_154_0",
        "label": "employee, salary, fptr, emp, birthday",
        "input": "<task:clean> <sos>\nUse this structure to read and display employees name id dob and salary include void main ( ) struct date int day int month int year struct employee char name int id struct dat dob float salary emp printf ( Name of Employee t ) scanf ( s empname ) printf ( n ID of employee t ) scanf ( d empid ) printf ( n Day of Birthday t ) scanf ( d empdobday ) printf ( n month of Birthday t ) scanf ( d empdobmonth ) printf ( n Year of Birthday t ) scanf ( d empdobyear ) printf ( salary of Employee t ) scanf ( d empsalary ) printf ( nn The Detail Information of Employee ) printf ( n Name t id t day t month t year t salary ) printf ( n n ) printf ( stdtdtdtdtfempnameempidempdobday empdobmonth empdobyear empdobsalary ) output Name of Employee Teena Id of Employee Day of Birthday Month of Birthday Year of Birthday Salary of Employee The Detail Information of employee Name ID Day Month Year Salary Teena Processing a Structure ( PU ) WAP to read records of employee ( Enter relevant fields Name address salary Id ) void main ( ) struct employee char nam char Address float salary int ID int i j float temp struct emp clrsc ( ) printf ( enteremployee Information ) for ( i i i ) for ( ji j j ) if ( empisalaryempjsalary ) temp empisalary empisalary empjsalary empjsalary temp printf ( Information of employees having highest salary In ) printf ( nNametttAddressttSalarytDtn ) printf ( n n ) for ( i i i ) printf ( sttsttftd empiName empiAddress empiSalary empiID ) getch ( ) PU Create a user defined array structure student record having members physics chemistry and mathematics\n<eos>"
    },
    {
        "key": "file2_topic_154_1",
        "label": "employee, salary, fptr, emp, birthday",
        "input": "<task:clean> <sos>\nUse this structure to read the name age and salary of employee and write entered information to a file employeedat in D drive include void main ( ) struct employee char empName int age float salary struct employee emp FILE fptr ftpr fopen ( demployeedat wb ) if ( fptr NULL ) printf ( File can not be entered ) exit ( ) printf ( Employee Name It ) scanf ( s emp\nempName ) printf ( employee age It ) scanf ( d empage ) printf ( salary of the employee It ) scarf ( f empsalary ) printf ( In writing this information to a file _ _ _ In ) fwrite ( emp sizeof ( emp ) fptr ) getch ( ) Create a structure named student that has name roll and marks as members\nwb ) if ( fptr NULL ) printf ( File cant be created ) exit ( ) for ( i i itt ) printf ( n Enter Information of student No d n i ) printf ( Name t ) scanf ( s siname ) printf ( n Rollt ) scanf ( d siroll ) printf ( n Marks t ) scanf ( f tempMarks ) simarks tempMarks printf ( n working Information to file _ _ _ _ _ n ) fwrite ( s size of ( s ) fptr ) rewind ( fptr ) printf ( n reading same content from file _ _ _ _ _ n ) fread ( st size of ( st ) fptr ) printf ( n student Name t Roll t Marks ) printf ( n _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ n ) for ( i i i ) printf ( sttdtf n stiname stiroll stimarks ) fclose ( fptr ) getch ( ) In Program read employee information again and again until user wants to add more employees\nFinally write a program to search information of a particular employee from the file\n<eos>"
    },
    {
        "key": "file2_topic_154_2",
        "label": "employee, salary, fptr, emp, birthday",
        "input": "<task:clean> <sos>\ninclude include struct employee char name int age float salary structemployee emp FILE fptr char yes_no name int dataFound clrscr ( ) fptr fopen ( Cemployeetxt wb ) if ( fptr NULL ) printf ( File can not be created ) exit ( ) Do printf ( employee Name t ) scanf ( s empname ) printf ( employee age t ) scanf ( d empage ) printf ( salary of the employee t ) scanf ( f empsalary ) fwrite ( emp size of ( emp ) fptr printf ( Do you want to add another employee\nPress Y or Y it ) fflush ( stdin ) yes_no getchar ( ) while ( yes_no y yes_no y ) printf ( Enter the name of employee which is to be searched ) fflush ( stdin ) gets ( name ) rewind ( fptr ) while ( fread ( emp size of ( emp ) fptr ) ) if ( strcmp ( empname name ) ) dataFound printf ( Name t Age t t Salarly n ) printf ( n _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ _ _ _ _ _ _ _ n ) print ( stdtfempname empage empsalary ) If ( dataFound ) print ( n Matching data not found ) getch ( ) Difference between text and binary mode Some Important Questions\n<eos>"
    },
    {
        "key": "file2_topic_155",
        "label": "students, structure, having, object, mathematics",
        "input": "<task:clean> <sos>\nWrite a program having a structure of student type\nMake use of array of structure to input information of students\nWrite a program to read the name roll no and name of five students using array of structure object\nCreate a user defined array structure student record having members physics chemistry and mathematics\nUse this structure to read and display records of students\n<eos>"
    },
    {
        "key": "file2_topic_156",
        "label": "files, data, necessary, binary, information",
        "input": "<task:clean> <sos>\nThese problems invite the concept of data file in which data can be stored on the disks and read whenever necessary without destroying data\nThe data file allows us to store information permanently and to access and alter that information whenever necessary\nMainly there are two types of data files\nThe standard data files are again subdivided into text files and binary files\nThe text files consist of consecutive characters and these characters can be interpreted as individual data item\nThe binary files organize data into blocks containing contiguous bytes of information\n<eos>"
    },
    {
        "key": "file2_topic_157",
        "label": "acess, record, fortyforth, sequentially, random",
        "input": "<task:clean> <sos>\nFor example if we want to acess the fortyfourth record then firsat forty three records should be read sequentially to reach the fortyforth record\nIn random acess data can be accessed and processed randomly ie\nin this case the fortyforth record can be accessed directly\nThere is no need to read each record sequentially if we want to acess a particularly record\nRandom acess takes takes less time than the sequential acess\n<eos>"
    },
    {
        "key": "file2_topic_158",
        "label": "text, graphics, mode, header, erases",
        "input": "<task:clean> <sos>\nThe text mode functions are concerned with placing text in certain area of screen\nSome text mode graphics function clrscr ( ) This function erases the text window\nIn text mode we can address only location ( ) but in graphicsmode we can address individual pixel or dots on the screen\nIf we want to use graphics mode functions then we have to add graphics h header file but for text mode function no need of graphics h header file\n<eos>"
    },
    {
        "key": "file2_topic_159",
        "label": "graphics, mode, adapter, monitor, driver",
        "input": "<task:clean> <sos>\nThey work with any graphics monitor and adapter\nThe graphics mode function require a graphics monitor and adapter card such as CGA EGA or VGA\nThis makes computer screen in specified graphics mode\nThis function initializes the graphics system by loading a graphics driver from disk then putting the system into graphics mode\nThis variable specifies the graphics driver are applicable only in graphics mode and they communicate directly with monitor\nDepending on what adapter is used one of these driver gets selected\nThe some constants defined in graphics h file for this argument are DETECT ( ) CGA ( ) EGA ( ) VGA ( ) etc\nClosing Graphics Mode Once a program has finished its job using the graphics facilities then it should restore the system to the mode that was previously in use ( ie\nthe graphics mode should be closed )\nIf graphics mode is not closed explicitly by the programmer undesirable effects may be felt\nIf we want to use the graphics mode functions then our first job is to set our computer mode to graphics mode\n<eos>"
    },
    {
        "key": "file2_topic_160",
        "label": "gotoxy, joining, cursor, draws, lineral",
        "input": "<task:clean> <sos>\nThe general syntax Window ( left top right bottom ) gotoxy ( ) The gotoxy ( ) library function points the cursor position within a text window its syntax is gotoxy ( xy ) text color ( ) function It is used to give color of any text\nThe syntax of line ( ) function is line ( x y x y ) where x y x y are integer type and they represent the coordinate ( x y ) and ( x y )\nThe above command draws a line joining two points with coordinates ( x y ) and ( x y )\nlineral ( ) the function lineral ( x y ) draws a line joining the current cursor position and a point at a distance of x in the horizontal and y in vertical direction\nlineto ( ) The function lineto ( x y ) draws a line joining the current cursor position and a point with coordinates x and y\n<eos>"
    },
    {
        "key": "file2_topic_161",
        "label": "color, background, getpixel, setbkcolor, textbackground",
        "input": "<task:clean> <sos>\nThe syntax of text color ( ) is text color ( color constant ) textbackground ( ) function This function is used to set background color of each character\nThe syntax is textbackground ( color constant ) Some color constants Color No\nColor name Black Blue Green Cyan Red Magenta Brown etc\nIts syntax is Putpixel ( int x int y int color ) getpixel ( ) gets color of specified pixel\nIts syntax is integer_variable getpixel ( int x int y ) setcolor ( ) It changes current drawing foreground color\nIts syntax is setcolor ( int color ) setbkcolor ( ) It changes the background color\nIts syntax is setbkcolor ( int color ) line ( ) The line ( ) function can draw a line\nInt P Drawpoly ( P ) setlinestyle ( ) This function can select different style of line\n<eos>"
    },
    {
        "key": "file2_topic_162",
        "label": "initgraph, mode, bgi, graphics, path",
        "input": "<task:clean> <sos>\nGraphics Mode Graphic function Initialization In order to initialize graphics we initgraph ( ) function\nIts general syntax is initgraph ( graphics_driver graphics_mode path to driver ) where graphics_driver is a variable of type int initialized to some constant that defined in graphicsh\nThe closegraph ( ) fuction is used to restore the screen to the mode it was in before we called initgraph ( ) and deallocates all memory allocated by the graphics system\nThe syntax of closegraph ( ) sunction is closegraph ( ) Graphics Mode In text mode we are restricted to display text or graphics character but in graphics mode we can display points lines and compleax shapes\nFunction initgraph ( ) sets our mode for graphics work\nThe syntax of initgraph ( ) function is initgraph ( driver mode path of bgi files ) where driver and mode both are integer type and path for bgi files means where our BGI files are in disk\nIf we want to set the mode of computer is graphics mode by initgraph ( ) function then we have to write the following set of statements intdriver mode driverDETECT initgraph ( driver mode Ctcbgi ) we are assuming that our bgi are in sub directory Ctcbgi therefore the path of bgi files is written in initgraph ( ) function like Ctcbgi The statement driverDETECT will check our hardware and select appropriate values for argument to function initgraph ( ) Some Graphics Mode Graphic Functions putpixel ( ) Plot a point with specified color\n<eos>"
    },
    {
        "key": "file2_topic_163",
        "label": "arc, draws, circle, rectangle, ellipse",
        "input": "<task:clean> <sos>\nrectangle ( ) The function rectangle ( x y x y ) draw rectangle where point ( x y ) is left top corner point of rectangle and point ( x y ) is right bottom corner\n( ) y x ( ) y x circle ( ) The function circle ( x y r ) draws a circle of radius r The coordinates of the centre of the circle is ( x y )\nr ( ) y x arc ( ) Function arc ( x y a a r ) draws an arc on the screen starting from angle a to a\nThe radius of the circle of which the arc forms a part is r and x y are its centre coordinates\nFor example arc ( ) Above statement draws an arc like ellipse ( ) The function ellipse ( x y c c a a x y ) draws an ellipse of centre ( c c )\nThe a and a are start and end angle of the arc x and y are the xaxis and yaxis radii\n<eos>"
    },
    {
        "key": "file2_topic_164",
        "label": "vertices, polygon, fillpoly, drawpoly, closed",
        "input": "<task:clean> <sos>\na drawpoly ( ) Function drawpoly ( int n int p ) draws n vertices of polygon\nTo draw a closed polugon with n vertices we must pass n coordinates\nfillpoly ( ) It draws and fills polygon\nIts syntax is fillpoly ( int n int p ) To draw a closed polygon with vertices we must pass n coordinates to fillpoly ( )\n<eos>"
    },
    {
        "key": "file2_topic_165",
        "label": "style, thickness, pattern, respectively",
        "input": "<task:clean> <sos>\nIts syntax is setlinestyle ( int style patern thickness ) The type of style and thickness is int type and the type of pattern is unsigned int type\nWhere style are SOLID_LINE DOTTED_LINE CENTRE_LINE DASHED_LINE USERBIT_LINE or integer number respectively\nThe pattern is required only if user defined style ( USERBIT_LINE ) is used\nThe thickness parameter can have value NORM_WIDTH or THICK_WIDTH or integer value or respectively\n<eos>"
    },
    {
        "key": "file2_topic_166",
        "label": "circle, draw, rectangle, detect, ctcbgi",
        "input": "<task:clean> <sos>\nSimple program using built in graphical function PU Program in c to draw a line a circle a rectangle and an ellipse include main ( ) int gd gm clrscr ( ) gd DETECT initgraph ( gd gm Ctcbgi ) setcolor ( ) line ( ) circle ( ) rectangle ( ) ellipse ( ) getch ( ) closegraph ( ) PU Program to draw concentric circle having radius m and units include main ( ) int gd DETECT gm clrscr ( ) initgraph ( gd gm Ctcbgi ) setcolor ( ) circle ( ) circle ( ) circle ( ) getch ( ) closegraphc ( ) Program to draw an arc include main ( ) int gd DETECT gm clrscr ( ) initgraph ( gd gm Ctcbgi ) arc ( ) getch ( ) closegraph ( ) Program to draw a polygon include main ( ) int gd DETECT gm int P ( ) clrscr ( ) initgraph ( gd gm Ctcbgi ) drawpoly ( P ) fillpoly ( P ) getch ( ) closegraph ( ) Some Important Questions Write a program to draw ( PU ) ( i ) Line ( ii ) Circle ( iii ) Rectangle ( iv ) Arc\nWrite a program using graphics to draw a rectangle and a circle\n( PU BACK ) Write a program in C to draw a circle a rectangle and an ellipse\n( PU ) Write a program in C that can display a circle and a rectangle\nChoose centre and radius of the circle as well as coordinates of the rectangle on your own\n( PU ) Write a program to draw concentric circles having radius and units\n<eos>"
    }
]