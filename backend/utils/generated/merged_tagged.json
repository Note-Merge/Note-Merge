[
    {
        "key": "merged_topic_0_0",
        "label": "checksum, data, items, layer, protocols, numbers, sum, send, message",
        "input": "<task:merge> <sos>\nThe checksum is used in the Internet by several protocols although not at the data link layer\nThe receiver can add all the numbers received ( including the checksum )\nThe sender initializes the checksum to and adds all data items and the checksum ( the checksum is considered as one data item and is shown in color )\nThe sender now sends six data items to the receiver including the checksum\nSince the value of the checksum is this means that the data is not corrupted\nThe receiver drops the checksum and keeps the other data items\nIf the checksum is not zero the entire packet is dropped\nThe checksum is sent with the data\nIf the value of checksum is the message is accepted otherwise it is rejected\nNote that if there is any corruption the checksum recalculated by the receiver is not all s\n\n++++\n\nIn the Internet the checksum technique is mostly used at the network and transport layer rather than the datalink layer\nThe generator then creates anextra extram mbitbit unit called the checksum which is sent with the message\nAt the destination the checker creates a new checksum from the combination of the message and sent checksum\nIf the checksup is all s the message is accepted other wise the message is discarded\nExample Suppose our data is a list of five bit numbers that we want to send to a destination\nIn addition to sending these numbers we send the sum of the numbers\nFor example if the set of numbers is ( ) we send ( ) where is the sum of the original numbers\nThe receiver adds the five numbers and compares the result with the sum\nIf the two are the same the receiver assumes no error accepts the five numbers and discards the sum\nFor Simplicity Example We can make the job of the receiver easier if we send the negative ( complement ) of the sum called the checksum\nIn this case we send ( )\nThe receiver can add all the numbers received ( including the checksum )\n<eos>"
    },
    {
        "key": "merged_topic_1_0",
        "label": "hamming, distance, minimum, dmin, scheme, coding, block",
        "input": "<task:merge> <sos>\nTable A code for error correction ( Example ) Note The Hamming distance between two words is the number of differences between corresponding bits\nExample Let us find the Hamming distance between two pairs of words\nThe Hamming distance d ( ) is because\nThe Hamming distance d ( ) is because Note The minimum Hamming distance is the smallest Hamming distance between all possible pairs in a set of words\n\n++++\n\nCoding schemes are divided into two broad categories Block coding Convolution coding Dataword Codeword Block Coding Message Messageis isdivided dividedinto intoblocks blockseach eachof ofk kbits bitscalled calleddatawords datawords We Weadd addr rredundant redundantbits bitsto toeach eachblock blockto tomake makethe thelength lengthn n k k r r The Theresulting resultingn nbitbitblocks blocksare arecalled calledcodewords codewords Datawords and codewords in block coding Block Coding With k bits we can create a combination of k datawords\nError Detection in Block coding Two conditions satisfy the error detection\nHamming Distance It is one of the central concept in coding for error control\nWhy do you think Hamming distance is important for error detection\nThe reason is that the Hamming distance between the received codeword and the sent codeword is the number of bits that are corrupted during transmission\ndmin used to define the minimum Hamming distance in a coding scheme\nThe dmin in this case is\nTable A code for error detection ( Example ) BLOCK CODING BLOCK CODING Minimum Hamming Distance Minimum Hamming Distance Find the minimum Hamming distance of the coding scheme in Table\nTable A code for error correction ( Example ) BLOCK CODING Three Parameters For any coding scheme we need three parameters\nCode word size n Dataword size k Minimum Hamming distance dmin A coding scheme C is written is C ( n k ) with a separate expression for dmin For example C ( ) with dmin and C ( ) with dmin\nRelationship in between Hamming distance and errors occurring Hamming distance between the sent and received codewords is the number of bits affected by the error\n<eos>"
    },
    {
        "key": "merged_topic_1_1",
        "label": "hamming, distance, minimum, dmin, scheme, coding, block",
        "input": "<task:merge> <sos>\nExample Find the minimum Hamming distance of the coding scheme in Table\nSolution We first find all Hamming distances\nSolution We first find all the Hamming distances\nNote To guarantee the detection of up to s errors in all cases the minimum Hamming distance in a block code must be dmin s\nExample The minimum Hamming distance for our first code scheme ( Table ) is\nExample A code scheme has a Hamming distance dmin\nError correction codes need to have an odd minimum distance (\nSo the minimum Hamming distance is dmin\nNote All Hamming codes discussed in this book have dmin\n\n++++\n\nFor example send codeword received codeword bits are in error and the Hamming distance is d ( ) Minimum Hamming Distance for Error Detection If s errors occur during transmission the Hamming distance between the sent codeword and received codeword is s If it is necessary to detect upto s errors the minimum hamming distance between the valid codes must be s so that the received codeword does not match a valid codeword\nTo guarantee the detection of up to s errors in all cases the minimum Hamming distance in a block code must be dmins The minimum Hamming distance for our first code scheme from the table is dmin s or s S So this code guarantees detection of only a single error\nDataword Codeword BLOCK CODING Minimum Distance for Error Correction To guarantee correction of up to tt errors in all cases the minimum Hamming distance in a block code must be dmin t\nBLOCK CODING Minimum Distance for Error Minimum Distance for Error Correction Correction Example BLOCK CODING A code scheme has a Hamming distance dmin\nError correction codes need to have anodd oddminimum minimumdistance distance (\nLinear Block Codes This is the widespread used coding scheme\nA linear block code is a code in which the exclusive OR of two valid codeword creates another valid codeword\nHamming codes Hamming codes were originally designed with dmin which means that can detect up to two errors or correct one single error\n<eos>"
    },
    {
        "key": "merged_topic_2_0",
        "label": "hamming, distance, minimum, dmin, scheme, words, pairs, distances",
        "input": "<task:merge> <sos>\nTable A code for error correction ( Example ) Note The Hamming distance between two words is the number of differences between corresponding bits\nExample Let us find the Hamming distance between two pairs of words\nThe Hamming distance d ( ) is because\nThe Hamming distance d ( ) is because Note The minimum Hamming distance is the smallest Hamming distance between all possible pairs in a set of words\nExample Find the minimum Hamming distance of the coding scheme in Table\nSolution We first find all Hamming distances\nSolution We first find all the Hamming distances\nNote To guarantee the detection of up to s errors in all cases the minimum Hamming distance in a block code must be dmin s\nExample The minimum Hamming distance for our first code scheme ( Table ) is\nExample A code scheme has a Hamming distance dmin\nError correction codes need to have an odd minimum distance (\nSo the minimum Hamming distance is dmin\nNote All Hamming codes discussed in this book have dmin\n\n++++\n\nThe Hamming distance between two words ( of the same size ) as the number of difference between the corresponding bits\nLet us find the Hamming distance between two pairs of words\nThe Hamming distance d ( ) is because\nThe Hamming distance d ( ) is because Hamming Distance Let us find the Hamming distance between two pairs of words\nThe Hamming distance d ( ) is because BLOCK CODING Minimum Hamming Distance Minimum Hamming Distance The minimum Hamming distance is the smallest Hamming distance all possible pairs in a set of words\nSolution We first find all Hamming distances\nSolution We first find all the Hamming distances\n<eos>"
    },
    {
        "key": "merged_topic_3_0",
        "label": "received, codeword, transmission, corrupted, accepts, receiver, dataword, syndrome",
        "input": "<task:merge> <sos>\nThe codeword is corrupted during transmission and is received\nThe receiver accepts the received codeword and the errors are undetected\nNo error occurs the received codeword is\nThe received codeword is\nThe codeword is received\n\n++++\n\nHence out of codewords are used for message transfer and rest are unused\nIf the receiver receives an invalid codeword this indicates that the data was corrupted during transmission\nThe receiver has a list of valid codewords\nLet k and n Dataword Codeword Let the sender encodes dataword as and send it receiver\nReceiver receives it is valid codeword\nDataword is extracted by receiver\nReceiver incorrectly extracts dataword\nDataword Codeword An errordetecting code can detect only the types of errors for which it is designed other types of errors may remain undetected\nIf the syndrome is there is no error in the received codeword codeword is accepted as the dataword if the syndrome is the data portion of the received codeword is discarded\nThe codeword created from this dataword is which is sent to the receiver\nThe dataword is created at the receiver\nNote that here the dataword is wrongly created due to the syndrome valueThe Thesimply simplyparity paritycheckcheckdecoder decodercannot cannotdetect detectan aneven evennumbers numbersof oferrors errors\nDataword becomes codeword is received syndrome no error\nThe dataword is sent as codeword\nRelationship among the sent codeword error received codeword and the generator\nThe receiver divides the received codeword by g ( x ) to get the syndrome\n<eos>"
    },
    {
        "key": "merged_topic_4_0",
        "label": "generator, note, simple, errors, isolated, paritycheck, odd, number, parity",
        "input": "<task:merge> <sos>\nNote A simple paritycheck code is a singlebit errordetecting code in which n k with dmin\nThis shows that the simple parity check guaranteed to detect one single error can also find any odd number of errors\nNote A simple paritycheck code can detect an odd number of errors\nNote In a cyclic code those e ( x ) errors that are divisible by g ( x ) are not caught\nNote If the generator has more than one term and the coefficient of x is all single errors can be caught\nExample Find the status of the following generators related to two isolated singlebit errors\nThis is a very poor choice for a generator\nA codeword with two isolated errors up to bits apart can be detected by this generator\nNote A generator that contains a factor of x can detect all oddnumbered errors\nNote A good polynomial generator needs to have the following characteristics\n\n++++\n\nSimple parityCheck Code In Simple paritycheck code a kbit dataword is changed to an nbit codeword where nk The extra bit called the parity bit The extra bit called the parity bit is selected to make the total number of s in the codeword even\nAlthough some implementations specify an odd number of s we discuss the even case\nA simple paritycheck code is a singlebit errordetecting code in which n k with dmin\nAt Generator ro aaaa ( modulo ) Where if number of s is even the result is zero if number of s is odd the result is one Minimum Distance for Linear Block Codes Simple paritycheck code C ( ) Minimum Distance for Linear Block Codes At Generator ro aaaa ( modulo ) Where if number of s is even the result is zero if number of s is odd the result is one The checker at the receiver does the same thing as the generator in the sender with one exception The addition is done over all bits\nSimple paritycheck ( Cont ) Assume the sender sends the dataword\nSimple paritycheck ( Cont )\n<eos>"
    },
    {
        "key": "merged_topic_5_0",
        "label": "codeword, received, receiver, table, dataword, syndrome",
        "input": "<task:merge> <sos>\nFirst the receiver finds that the received codeword is not in the table\nThe receiver assuming that there is only bit corrupted uses the following strategy to guess the correct dataword\nComparing the received codeword with the first codeword in the table ( versus ) the receiver decides that the first codeword is not the one that was sent because there are two different bits\nThe original codeword must be the second one in the table because this is the only one that differs from the received codeword by bit\n\n++++\n\nHence out of codewords are used for message transfer and rest are unused\nIf the receiver receives an invalid codeword this indicates that the data was corrupted during transmission\nThe receiver has a list of valid codewords\nLet k and n Dataword Codeword Let the sender encodes dataword as and send it receiver\nReceiver receives it is valid codeword\nDataword is extracted by receiver\nReceiver incorrectly extracts dataword\nDataword Codeword An errordetecting code can detect only the types of errors for which it is designed other types of errors may remain undetected\nIf the syndrome is there is no error in the received codeword codeword is accepted as the dataword if the syndrome is the data portion of the received codeword is discarded\nThe codeword created from this dataword is which is sent to the receiver\nThe dataword is created at the receiver\nNote that here the dataword is wrongly created due to the syndrome valueThe Thesimply simplyparity paritycheckcheckdecoder decodercannot cannotdetect detectan aneven evennumbers numbersof oferrors errors\nDataword becomes codeword is received syndrome no error\nThe dataword is sent as codeword\nRelationship among the sent codeword error received codeword and the generator\nThe receiver divides the received codeword by g ( x ) to get the syndrome\n<eos>"
    },
    {
        "key": "merged_topic_6_0",
        "label": "complement, arithmetic, ones, number, using, represent",
        "input": "<task:merge> <sos>\nNote In moduloN arithmetic we use only the integers in the range to N inclusive\nExample How can we represent the number in ones complement arithmetic using only four bits\nSolution The number in binary is ( it needs five bits )\nWe can wrap the leftmost bit and add it to the four rightmost bits\nSolution In ones complement arithmetic the negative or complement of a number is found by inverting all bits\nPositive is negative is\nIf we consider only unsigned numbers this is\nIn other words the complement of is\nAnother way to find the complement of a number in ones complement arithmetic is to subtract the number from n ( in this case )\nExample Let us redo Exercise using ones complement arithmetic\nHowever can not be expressed in bits\nThe extra two bits are wrapped and added with the sum to create the wrapped sum value\nThe sum is wrapped and becomes\nAll words are added using ones complement addition\n\n++++\n\nOnes Complement The previous example has one major drawback\nWe have solution to use ones complement arithmetic\nIn this ones complement arithmetic we can represent unsigned numbers between and mm using only m bits\nIn ones complement arithmetic we have two s one positive and one negative which are complements of each other\nHow can we represent the number in ones complement arithmetic using only four bits\nWe have ( ) ( ) ( ) ( ) How can we represent the number in ones complement arithmetic using only four bits\nSolution In ones complement arithmetic the negative or complement of a number is found by inverting all bits\nPositive is Ones complement of is If we consider only unsigned number this is\nIn other words the complement of is\n<eos>"
    },
    {
        "key": "merged_topic_7_0",
        "label": "valid, codeword, match, sent, errors, receiver, dataword, received, syndrome",
        "input": "<task:merge> <sos>\nFor example if the third codeword ( ) is sent and one error occurs the received codeword does not match any valid codeword\nIf two errors occur however the received codeword may match a valid codeword and the errors are not detected\nAgain we see that when any of the valid codewords is sent two errors create a codeword which is not in the table of valid codewords\nHowever some combinations of three errors change a valid codeword to another valid codeword\nOtherwise there is an error somewhere and the data are not accepted\n\n++++\n\nHence out of codewords are used for message transfer and rest are unused\nIf the receiver receives an invalid codeword this indicates that the data was corrupted during transmission\nThe receiver has a list of valid codewords\nLet k and n Dataword Codeword Let the sender encodes dataword as and send it receiver\nReceiver receives it is valid codeword\nDataword is extracted by receiver\nReceiver incorrectly extracts dataword\nDataword Codeword An errordetecting code can detect only the types of errors for which it is designed other types of errors may remain undetected\nIf the syndrome is there is no error in the received codeword codeword is accepted as the dataword if the syndrome is the data portion of the received codeword is discarded\nThe codeword created from this dataword is which is sent to the receiver\nThe dataword is created at the receiver\nNote that here the dataword is wrongly created due to the syndrome valueThe Thesimply simplyparity paritycheckcheckdecoder decodercannot cannotdetect detectan aneven evennumbers numbersof oferrors errors\nDataword becomes codeword is received syndrome no error\nThe dataword is sent as codeword\nRelationship among the sent codeword error received codeword and the generator\nThe receiver divides the received codeword by g ( x ) to get the syndrome\n<eos>"
    },
    {
        "key": "merged_topic_8_0",
        "label": "divisible, divide, useless, greater, polynomial, remainder, xoois, xig",
        "input": "<task:merge> <sos>\nNo xi can be divisible by x\nIf i is equal to or greater than xi is divisible by g ( x )\nc All values of i make xi divisible by g ( x )\nThis g ( x ) is useless\nd This polynomial can not divide xt if t is less than\nIt should not divide xt for t between and n\n\n++++\n\nIf the term does not have remainder ( syndrome ) either e ( x ) or e ( x ) is divisible by g ( x )\nthen xig ( x ) will have a remainder\nIf g ( x ) have at least two terms and the coefficient ofx xoois is then e ( x ) can not be divided by g ( x ) ie there will be some remainder\nNo xi can be divisible by x\nIf i is equal to or greater than xi is divisible by g ( x )\nc All values of i make xi divisible by g ( x )\n<eos>"
    },
    {
        "key": "merged_topic_9_0",
        "label": "error, discuss, detection, correction, section, data, applications, require, chances, corrupt",
        "input": "<task:merge> <sos>\nSome applications require that errors be detected and corrected\nINTRODUCTION Let us first discuss some issues related directly or indirectly to error detection and correction\nLet us first discuss some issues related directly or indirectly to error detection and correction\nTopics discussed in this section Types of Errors Redundancy Detection Versus Correction Forward Error Correction Versus Retransmission Coding Modular Arithmetic Topics discussed in this section Note In a singlebit error only bit in the data unit has changed\nTable A code for error detection ( Example ) Note An errordetecting code can detect only the types of errors for which it is designed other types of errors may remain undetected\nWhat is the error detection and correction capability of this scheme\nIn other words if this code is used for error correction part of its capability is wasted\nFor each case what is the error that can not be caught\nTable Standard polynomials CHECKSUM The last error detection method we discuss here is called the checksum\nHowever we briefly discuss it here to complete our discussion on error checking The last error detection method we discuss here is called the checksum\nHowever we briefly discuss it here to complete our discussion on error checking Topics discussed in this section Idea Ones Complement Internet Checksum Topics discussed in this section Example Suppose our data is a list of five bit numbers that we want to send to a destination\nIf the result is it assumes no error otherwise there is an error\n\n++++\n\nData Link Layer Data can be corrupted during transmission\nduring transmissionSome applications require that Some applications require that errors be detected and corrected\nData can be corrupted Error Detection and Correction Network must be able to transfer data from one devices to another with acceptable accuracy\nThe chances of data being corrupt can not be ignored\nThe number of errors and the size of the message are important factors\nWhat is the error detection and correction capability of this scheme\n<eos>"
    },
    {
        "key": "merged_topic_10_0",
        "label": "generator, note, simple, errors, isolated, divisible, caught, useless, criteria",
        "input": "<task:merge> <sos>\nNote A simple paritycheck code is a singlebit errordetecting code in which n k with dmin\nThis shows that the simple parity check guaranteed to detect one single error can also find any odd number of errors\nNote A simple paritycheck code can detect an odd number of errors\nNote In a cyclic code those e ( x ) errors that are divisible by g ( x ) are not caught\nNote If the generator has more than one term and the coefficient of x is all single errors can be caught\nExample Find the status of the following generators related to two isolated singlebit errors\nThis is a very poor choice for a generator\nA codeword with two isolated errors up to bits apart can be detected by this generator\nNote A generator that contains a factor of x can detect all oddnumbered errors\nNote A good polynomial generator needs to have the following characteristics\n\n++++\n\nTo find the criteria that must be imposed on the generator g ( x ) to detect the type of error that need to be detected\nThose errors that are not divisible by g ( x ) are not In a cyclic code those e ( x ) errors that are divisible by g ( x ) are not caught\nNote If the generator has more than one term and the coefficient of x is all single errors can be caught\nThis g ( x ) is useless\n<eos>"
    },
    {
        "key": "file1_topic_11",
        "label": "blocks, redundant, add, make, nbit",
        "input": "<task:clean> <sos>\nWe add r redundant bits to each block to make the length n k r The resulting nbit blocks are called codewords\nIn block coding we divide our message into blocks each of k bits called datawords\nWe add redundant bits to the bit dataword to make bit codewords\n<eos>"
    },
    {
        "key": "file1_topic_12",
        "label": "set, acceptable, satisfies, condition, relationship",
        "input": "<task:clean> <sos>\nIn this coding scheme k and n\nThe relationship between m and n in these codes is n m\nCalculate values of k and n that satisfy this requirement\nSolution We need to make k n m greater than or equal to or m m\nIf we set m the result is n and k or which is not acceptable\nIf we set m then n and k which satisfies the condition\n<eos>"
    },
    {
        "key": "file1_topic_13",
        "label": "dataword, flipping, changing, derive, wrong",
        "input": "<task:clean> <sos>\nAs we saw we have k datawords and n codewords\nLater we will see how to derive a codeword from a dataword\nAssume the dataword is\nThe dataword becomes the codeword\nAfter flipping b ( changing the to ) the final dataword is\nAfter flipping b we get the wrong dataword\n<eos>"
    },
    {
        "key": "file1_topic_14",
        "label": "column, digit, shows, datawords, process",
        "input": "<task:clean> <sos>\nTable shows the list of datawords and codewords\nTable shows the datawords and codewords\nWe keep the rightmost digit ( ) and insert the leftmost digit ( ) as the carry in the second column\nThe process is repeated for each column\n<eos>"
    },
    {
        "key": "file1_topic_15",
        "label": "continued, example, follows, examine, procedure",
        "input": "<task:clean> <sos>\nExample ( continued )\nWe examine five cases\nIt should have at least two terms\nExample ( continued ) The receiver follows the same procedure as the sender\nWe leave this an exercise\n<eos>"
    },
    {
        "key": "file1_topic_16",
        "label": "singlebit, caught, error, corrupted, changes",
        "input": "<task:clean> <sos>\nTwo corrupted bits have made the error undetectable\nOne singlebit error changes a\nOne singlebit error changes r\nThree bitsa a and aare changed by errors\nNo bit is corrupted\nSome bits are corrupted but the decoder failed to detect them\nExample Which of the following g ( x ) values guarantees that a singlebit error is caught\nAny singlebit error can be caught\nAll singlebit errors in positions to are caught\nNo singlebit error can be caught\n<eos>"
    },
    {
        "key": "file1_topic_17",
        "label": "dmin, case, code, second",
        "input": "<task:clean> <sos>\nThe dmin in this case is\nExample Our second block code scheme ( Table ) has dmin\nSo in this code we have dmin\n<eos>"
    },
    {
        "key": "file1_topic_18",
        "label": "guarantees, correct, code, errors, detection",
        "input": "<task:clean> <sos>\nThis code guarantees detection of only a single error\nThis code can detect up to two errors\nSolution This code guarantees the detection of up to three errors ( s ) but it can correct up to one error\nThis shows that our code can not correct two errors\nAny two errors next to each other can not be detected\n<eos>"
    },
    {
        "key": "file1_topic_19",
        "label": "linear, block, codes, valid, code",
        "input": "<task:clean> <sos>\nLINEAR BLOCK CODES Almost all block codes used today belong to a subset called linear block codes\nA linear block code is a code in which the exclusive OR ( addition modulo ) of two valid codewords creates another valid codeword\nAlmost all block codes used today belong to a subset called linear block codes\nTopics discussed in this section Minimum Distance for Linear Block Codes Some Linear Block Codes Topics discussed in this section Note In a linear block code the exclusive OR ( XOR ) of any two valid codewords creates another valid codeword\nExample Let us see if the two codes we defined in Table and Table belong to the class of linear block codes\nThe scheme in Table is a linear block code because the result of XORing any codeword with any other codeword is a valid codeword\nFor example the XORing of the second and third codewords creates the fourth one\nThe scheme in Table is also a linear block code\nIn a cyclic code if a codeword is cyclically shifted ( rotated ) the result is another codeword\nCyclic codes are special linear block codes with one extra property\n<eos>"
    },
    {
        "key": "file1_topic_20",
        "label": "created, dataword, wrongly, value, syndrome",
        "input": "<task:clean> <sos>\nThe dataword is created\nNo dataword is created\nNote that here the dataword is wrongly created due to the syndrome value\nThe dataword is not created\n<eos>"
    },
    {
        "key": "file1_topic_21",
        "label": "burst, length, slip, errors",
        "input": "<task:clean> <sos>\nNote All burst errors with L r will be detected\nAll burst errors with L r will be detected with probability ( ) r\nAll burst errors with L r will be detected with probability ( ) r Example Find the suitability of the following generators in relation to burst errors of different lengths\nThis generator can detect all burst errors with a length less than or equal to bits out of burst errors with length will slip by out of burst errors of length or more will slip by\nThis generator can detect all burst errors with a length less than or equal to bits out of million burst errors with length will slip by out of million burst errors of length or more will slip by\nc This generator can detect all burst errors with a length less than or equal to bits out of billion burst errors with length will slip by out of billion burst errors of length or more will slip by\n<eos>"
    },
    {
        "key": "file1_topic_22",
        "label": "numbers, sum, send, receiver, easier",
        "input": "<task:clean> <sos>\nIn addition to sending these numbers we send the sum of the numbers\nFor example if the set of numbers is ( ) we send ( ) where is the sum of the original numbers\nThe receiver adds the five numbers and compares the result with the sum\nIf the two are the same the receiver assumes no error accepts the five numbers and discards the sum\nExample We can make the job of the receiver easier if we send the negative ( complement ) of the sum called the checksum\n<eos>"
    },
    {
        "key": "file1_topic_23",
        "label": "complemented, checksum, sum, value, new",
        "input": "<task:clean> <sos>\nThe sum is then complemented resulting in the checksum value ( )\nThe value of the checksum word is set to\nAll words including the checksum are added using ones complement addition\nThe sum is complemented and becomes the checksum\nThe sum is complemented and becomes the new checksum\nExample Let us calculate the checksum for a text of characters ( Forouzan )\n<eos>"
    },
    {
        "key": "file1_topic_24",
        "label": "divided, byte, words, bit, message",
        "input": "<task:clean> <sos>\nThe message is divided into bit words\nThe message ( including checksum ) is divided into bit words\nThe text needs to be divided into byte ( bit ) words\nWe use ASCII ( see Appendix A ) to change each byte to a digit hexadecimal number\n<eos>"
    },
    {
        "key": "file2_topic_25",
        "label": "redundant, bits, data, second, correct",
        "input": "<task:clean> <sos>\nIf a data is sent at mbps then each one bit last only for second ( ( u ) micro second )\nInstead of repeating the entire data stream a shorter group of bits may be appended to the end of each unit\nThis technique is called Redundancy These extra bits are discarded as soon as the accuracy of the transmission has been determined\nTo detect or correct errors we need to send extra ( redundant ) bits with data\nForward Error Correction Process in which the receiver tries to guess the message by Redundant bit\n( usually not all errors are detected ) Coding The sender adds redundant bits The receiver checks the relationships between the two sets of bits to detect or correct the errors\nAt the source the message is first divided into mbits units\n<eos>"
    },
    {
        "key": "file2_topic_26",
        "label": "bits, zero, codewords, augment, means",
        "input": "<task:clean> <sos>\nSince n bits we can create a combination of n codewords\nSince n k The possibility codeword is greater than possible data words\nThis means we have n k codewords extra\nEg if k and n we have dataword and codewords\nThis means that we have n k codewords that are not used\nA codeword consists of n bits of which k are data bits and r are check bits\nDataword ( k ) if codeword ( n ) bits\nAugment dataword by ( nk ) zero bits ie zero bits\nAugment DW by ( nk ) zero bits ie zero bits\nSo general DP n bit if n is number of bits\nAll our data can be written as a bitbitword word ( they ( theyare areless lessthan than ) ) except the checksum\n<eos>"
    },
    {
        "key": "file2_topic_27",
        "label": "invalid, valid, codewords, illegal, corrupted",
        "input": "<task:clean> <sos>\nWe call these codewords invalid or illegal\nThe original codewords has changed to an invalid one\nCode word is corrupted\nThis is not a valid codeword and it is discarded\nCodeword is corrupted but this is valid codeword\n<eos>"
    },
    {
        "key": "file2_topic_28",
        "label": "sbbbq, mod, raaa, modulo, syndrome",
        "input": "<task:clean> <sos>\nThe syndrome is when the number of s in the received codeword is even otherwise it is The syndrome is passed to the decision logic analyzer\nraaa ( modulo ) raaa ( modulo ) raaa ( modulo ) raaa ( modulo ) raaa ( modulo ) raaa ( modulo ) At Checker Sbbbq ( mod ) Sbbbq ( mod ) Sbbbq ( mod ) The bit syndrome creates different bit patterns ( to ) that can represent different conditions\nSyndrome Error None q q b q b b b Fig logical decision made by the correction logic Analyzer In Syndrome is not concerned with generator since there is error or an error in the parity bit\nIn Syndrome one of the bits must be flipped ( from to or from to ) to find correct dataword\nSbbbq ( mod ) Sbbbq ( mod ) Sbbbq ( mod Dataword Codeword Cases\nAfter flipping b ( changing to ) the final dataword is obtained\nSyndrome b b b Dataword Codeword\nSbbbq ( mod ) Sbbbq ( mod ) Sbbbq ( mod ) After flipping b we get ( wrong dataword )\n<eos>"
    },
    {
        "key": "file2_topic_29_0",
        "label": "cyclic, generator, divisor, codeword, encoder",
        "input": "<task:clean> <sos>\nIn a cyclic code if a codeword is cyclically shifted ( rotated ) the result is another codeword\nFor example if is a codeword and we cyclically leftshift then is also a codeword\nIn this case if we call the bits in the first word a to a and the bits in the second word b to b we can shift the bits by using the following ba ba ba ba ba ba ba A category of cyclic code is Cyclic Redundancy Check ( CRC ) Used in LANs WANs Cyclic Redundancy Check The generator uses nk bit divisor which is predefined and agreed The remainder ( bit ) is appended to the dataword to make the final codeword At Encoder In encoder the dataword has k bits ( here ) The codeword has n bits ( here ) The size of the dataword is augmented by adding n k ( here ) The generator uses adivisor divisorof ofsize size nk ( here ) The quotient of the division is discarded\nThe remainder ( rrr ) is appended to the dataword to create the codeword\nie Let the divisor is ( Predefined and agreed ) ( nk ) digits The remainder ( rrr ) is appended to the dataword to create the codeword At decoder Decoder does the same division as encoder\nPolynomials A better way to understand cyclic codes and how they can be analyzed is to represent them as polynomials\nThe divisor in a cyclic code is normally called the generator polynomial or simply the generator\nCyclic Code Analysis The divisor is normally called the generator polynomial or generator Analysis Let f ( x ) is a polynomial with binary coefficient d ( x ) Dataword c ( x ) Codeword g ( x ) Generator s ( x ) Syndrome e ( x ) Error Note In a cyclic code If s ( x ) one or more bits is corrupted\n<eos>"
    },
    {
        "key": "file2_topic_29_1",
        "label": "cyclic, generator, divisor, codeword, encoder",
        "input": "<task:clean> <sos>\nWe can write this The first term at the right hand side of the equality has a remainder of zero ( according to the definition of codeword )\n<eos>"
    },
    {
        "key": "file2_topic_30",
        "label": "right, shifting, bits, leftmost, rightmost",
        "input": "<task:clean> <sos>\nThe bit pattern in this case has bits\n( xxxx ) ( xx ) ( let the student do rest of the problem ) xxxxx Shifting A binary pattern is often shifted a number of bits to the right or left\nShifting to the left means adding s extra bit at right side\nShifting to the Right means deleting some right most bits\nIf the number has more thanm m bits the extra leftmost bits need to be added to them m rightmost bits ( wrapping )\nSolution The number is binary is ( it needs six bits )\nWe can wrap the leftmost bit and add it to the four rightmost bits\n<eos>"
    },
    {
        "key": "file2_topic_31",
        "label": "terms, subtraction, multiplying, deleted, powers",
        "input": "<task:clean> <sos>\nAddition Subtraction Addition or subtraction is done by combining terms and deleting pairs of identical terms\n( xxx ) ( xxx ) x x X and x are deleted Multiplying or dividing terms Just add the powers of multiplication\nX x x Subtract the powers for division\nXx x Multiplying two polynomials It is conceptually same as we did it for the encoderdecoder pairs equal terms are deleted\n<eos>"
    }
]